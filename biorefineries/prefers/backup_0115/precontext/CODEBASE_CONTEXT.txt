======================================================================
PREFERS V1 CODEBASE CONTEXT
Generated: 2026-01-15 15:18:42
Source: C:\Programming\PREFERS\Bioindustrial-Park\biorefineries\prefers\v1
======================================================================

TABLE OF CONTENTS
----------------------------------------
   1. __init__.py
   2. HemeIn\__init__.py
   3. HemeIn\chemicals.py
   4. HemeIn\streams.py
   5. HemeIn\system.py
   6. LegH\__init__.py
   7. LegH\chemicals.py
   8. LegH\models.py
   9. LegH\streams.py
  10. LegH\system.py
  11. LegH\tea.py
  12. process_settings.py
  13. units.py



================ FILE: __init__.py ================

# -*- coding: utf-8 -*-
"""
PREFERS v1 - Production Package

Versioned, modular BioSTEAM package for precision fermentation simulations.
"""

from . import units
from . import process_settings
from . import LegH
from . import HemeIn

__all__ = ['units', 'process_settings', 'LegH', 'HemeIn']



================ FILE: HemeIn\__init__.py ================

# -*- coding: utf-8 -*-
"""
HemeIn Subpackage - Hemodextrin (Heme) Production

This subpackage contains all modules specific to the HemeIn (Hemodextrin) production process.

Modules:
    - chemicals: Chemical species definitions for Hemodextrin process
    - system: Main flowsheet/system factory
    - streams: Input stream definitions

@author: Dr. Ouwen Peng
@institute: Illinois ARCS
"""

from .chemicals import create_chemicals_Hemodextrin, chemical_groups
from .system import create_Heme_system
from .streams import *

__all__ = (
    'create_chemicals_Hemodextrin',
    'chemical_groups',
    'create_Heme_system',
)



================ FILE: HemeIn\chemicals.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-04-30 15:36:46

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

# %%
#from biorefineries.ethanol_adipic._chemicals import chems
import biosteam as bst
from networkx import density
import thermosteam as tmo
import numpy as np
from thermosteam.utils import chemical_cache
from thermosteam import functional as fn
import pandas as pd
from fractions import Fraction

from traitlets import default
__all__ = (
    'get_grouped_chemicals',
    'create_chemicals_LegH',
)

# %% Constants

# Heats of formation for cellulosic components are from Humbird 2011 report: https://www.nrel.gov/docs/fy11osti/47764.pdf
# They are originally found in calories, so we need to convert them to joule.
_cal2joule = 4.184 # auom('cal').conversion_factor('J')
Cp_cellulosic = 1.364

#: Default liquid chemicals for saccharification solids-loading specification
default_nonsolids = ['Water', 'Ethanol', 'AceticAcid', 
                    'H2SO4', 'NH3']

chemical_groups = dict(
    LegHIngredients = ('Leghemoglobin',
                    'TrehaloseDH',
                    'SodiumAscorbate',
                    ),
    Addictive = ('Pichia_pastoris',
                'Glycine',
                'TrehaloseDH',
                'SodiumAscorbate',),

    # Negtive
    BoundImpurities = (
                    'EDTA',
                    'Glycine',
                    'RNA',
                    'Mannoprotein',
                    'OleicAcid'),

    ElutionBuffer = ('NaCl',
                    'KCl'),

    Salts = ('KOH',
            'NaCl',
            'KCl',
            '(NH4)2SO4',
            'FeSO4',
            'MgSO4',
            'KH2PO4',
            'K2HPO4',
            '(NH4)2HPO4',
            'K2HPO4',
            'NH3',
            'Na2SO4',
            'NaHSO4',
            'NaOH',
            'NaH2PO4',
            'Na2HPO4',
            'NH3',
            'HCl',
            'H2SO4',
            ),
    
    OtherLargeMolecules = (#'Cellmass',
                        'Yeast',
                        'Pichia_pastoris',
                        'Z_mobilis',
                        'T_reesei',
                        'Biomass',
                        'Cellulose',
                        'Glucan',
                        'Xylan',
                        'Xylitol',
                        'Cellobiose',
                        'CSL',
                        'Globin',
                        'Mannoprotein',
                        'Chitin',
                        'OleicAcid',
                        'RNA'),

    # DefaultSolutes = ('Glycine',
    #                     'CitricAcid',
    #                     'AceticAcid',
    #                     'LacticAcid',
    #                     'Glucose',
    #                     'Dextrose',
    #                     'IPTG',
    #                     'Ethanol',
    #                     'Glycerol',
    #                     'SuccinicAcid',
    #                     'Heme_b',
    #                     'RNA'),

    OtherSugars = ('Arabinose',
                    'Mannose',
                    'Galactose',
                    'Cellobiose',
                    'Sucrose'),
    OrganicSolubleSolids = ('AmmoniumAcetate',
                            'SolubleLignin',
                            'Extract', 
                            'LacticAcid', 
                            'Cellulase'),
    COxSOxNOxH2S = ('NO',
                    'NO2',
                    'SO2',
                    'CO',
                    'H2S'),  
    Protein = ('Protein',
                'Enzyme',
                'DenaturedEnzyme'),
    # Cellmass = ('WWTsludge',
    #             'Z_mobilis',
    #             'T_reesei'),                        
)

def get_grouped_chemicals(stream, units='kmol/hr'):
    new_stream = tmo.Stream(stream.thermo)
    new_stream.set_flow(stream.mol, units, stream.chemicals.IDs)
    data = {group: new_stream.get_flow(units, IDs).sum() for group, IDs in chemical_groups.items()}
    return pd.Series(data)


# %%
#@chemical_cache
def create_chemicals_LegH():
    ##############################################
    ##### set function of create new chemical ####
    ##############################################    
    chems = bst.Chemicals([])

    def add_chemical(ID, source=None, Cp=None, **data):
        chemical = tmo.Chemical.blank(ID, **data)
        if source: 
            default_phase_ref = source.phase_ref
            chemical.copy_models_from(source)
        else:
            default_phase_ref = 'l'
        if not chemical.phase_ref:
            chemical.phase_ref = default_phase_ref
        chemical.at_state(chemical.phase_ref)
        if Cp is not None: set_Cp(chemical, Cp)
        chemical.default()
        chems.append(chemical)

    def append_chemical(ID, search_ID=None, **data):
        chemical = tmo.Chemical(ID, search_ID=search_ID, **data)
        try: chemical.at_state(phase=chemical.phase_ref)
        except: pass
        chemical.default()    
        chems.append(chemical)
    
    def extend_chemical(IDs, **data):
        for ID in IDs: append_chemical(ID, **data)
    
    def append_chemical_copy(ID, chemical):
        new_chemical = chemical.copy(ID)
        chems.append(new_chemical)
    
    def set_Cp(single_phase_chemical, Cp):
        chem = single_phase_chemical
        chem.Cn.add_model(Cp * chem.MW, top_priority=True)
    
    def set_rho(single_phase_chemical, rho):
        V = fn.rho_to_V(rho, single_phase_chemical.MW)
        single_phase_chemical.V.add_model(V, top_priority=True)   

    def add_chemical(ID, ref=None, **data):
        chemical = bst.Chemical(ID, **data) if ref is None else ref.copy(ID, **data)
        chems.append(chemical)
        return chemical
    
    #########################
    #### Define Species #####
    #########################

    #### General Liquid #####
    add_chemical('H2O')
    add_chemical('H2SO4', phase='l')

    #### Gases ####
    add_chemical('O2', phase='g', Hf=0)
    add_chemical('N2', phase='g', Hf=0)
    add_chemical('CH4', phase='g')
    add_chemical('CO', search_ID='CarbonMonoxide', phase='g', Hf=-26400*_cal2joule)
    add_chemical('CO2', phase='g')
    add_chemical('NH3', phase='g', Hf=-10963*_cal2joule)
    add_chemical('NO', search_ID='NitricOxide', phase='g',formula='NO', Hf=82.05)
    add_chemical('NO2', phase='g', formula='NO2', Hf=7925*_cal2joule)
    add_chemical('H2S', phase='g', Hf=-4927*_cal2joule)
    add_chemical('SO2', phase='g')

    ##### Soluble inorganics #####
    add_chemical('KOH', phase='l', default=True)
    add_chemical('NaOH', phase='l', default=True)
    add_chemical('NaCl', phase='l', default=True)
    add_chemical('KCl', phase='l', default=True)

    add_chemical('(NH4)2SO4', phase='l', default=True, Hf=-288994*_cal2joule,aliases=['AmmoniumSulfate'])
    add_chemical('FeSO4', phase='l', default=True)
    add_chemical('MgSO4', phase='l', default=True) # 0.0001 $/kg
    Na2SO4 = add_chemical('Na2SO4', phase='l', default=True)
    Na2SO4.V.add_model(fn.rho_to_V(rho=2664, MW=Na2SO4.MW), top_priority=True)  # Density of solid Na2SO4
    
    NaHSO4 = add_chemical('NaHSO4', phase='l', default=True)
    NaHSO4.V.add_model(fn.rho_to_V(rho=2435, MW=NaHSO4.MW), top_priority=True)  # Density of solid NaHSO4

    add_chemical('KH2PO4', phase='l', default=True)
    add_chemical('K2HPO4', phase='l', default=True)
    add_chemical('NaH2PO4', phase='l', default=True)
    add_chemical('Na2HPO4', phase='l', default=True)
    add_chemical('(NH4)2HPO4', phase='l', default=True)
    
    # trace_metal_solution
    add_chemical('HCl', phase='l', default=True)
    add_chemical('CaCl2', phase='s', default=True)
    add_chemical('ZnSO4', phase='s', default=True)
    add_chemical('MnSO4', phase='s', default=True)
    add_chemical('CoCl2', phase='s', default=True)
    add_chemical('CuSO4', phase='s', default=True)
    add_chemical('(NH4)6Mo7O24', search_ID='PubChem=61578', phase='s', default=True)
    add_chemical('Na2B4O7', phase='s', default=True)

    #### Main Organic ####
    add_chemical('Glycine', phase='s')
    add_chemical('CitricAcid', phase='l', default=True)
    add_chemical('AceticAcid', phase='l', default=True)
    add_chemical('LacticAcid', phase='l', default=True)
    add_chemical('Glucose', phase='s', default=True)
    add_chemical('Dextrose', phase='l', default=True)
    add_chemical('IPTG', phase='l', default=True)
    #add_chemical('Tryptone', phase='l', default=True)
    add_chemical('Ethanol', phase='l', default=True)
    add_chemical('Glycerol', phase='s', default=True)
    add_chemical('SuccinicAcid', phase='s', default=True)
    add_chemical('EDTA', phase='s', default=True)
    add_chemical('Trehalose', search_ID='PubChem=7427', phase='s', default=True)
    add_chemical('TrehaloseDH', search_ID='6138-23-4', phase='s', default=True)
    add_chemical('SodiumAscorbate', search_ID='134-03-2', phase='s', default=True)

    # antibiotics   
    add_chemical('Ampicillin', phase='l', default=True)
    add_chemical('Kanamycin', phase='l', default=True)
    add_chemical('Streptomycin', phase='l', default=True)
    add_chemical('Chloramphenicol', phase='l', default=True)
    
    CaSO4 = add_chemical('CaSO4', phase='s', default=True)
    CaO = add_chemical('CaO', phase='s', default=True)
    soluble_solids = [CaO]
    Ash=add_chemical('Ash',MW=1.,search_db=False) # Dummy chemical for ash
    P4010 = add_chemical('P4O10',phase = 'l',Hf=-582000*_cal2joule) # For phosphate precipitation
    insoluble_solids = [Ash, P4010]

    for chemical in insoluble_solids:
        V = fn.rho_to_V(rho=1540, MW=chemical.MW)
        try: chemical.V.s.add_model(V, top_priority=True)
        except: pass
    for chemical in soluble_solids:
        V = fn.rho_to_V(rho=1e5, MW=chemical.MW)
        try: chemical.V.add_model(V, top_priority=True)
        except: pass

    Ash.Cn.s.add_method(0.09 * 4.184 * Ash.MW) # Heat capacity model
    
    # Add missing thermodynamic properties for ash
    Ash.Psat.add_method(1e-10)
    Ash.Tb = 3000  # High boiling point for solid
    Ash.Hvap.add_method(0)

    Ash.get_missing_properties()

    #############
    #### Bio ####
    #############

    Yeast = add_chemical(
        'Yeast',
        phase='s',
        formula='CH1.61O0.56',#N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        #aliases=['Cellmass'],
    )
    Yeast.Hf = chems.Glucose.Hf / chems.Glucose.MW * Yeast.MW 
    # Same as glucose to ignore heats related to growth 

    # https://microbialcellfactories.biomedcentral.com/articles/10.1186/1475-2859-11-57/tables/2?utm_source=chatgpt.com
    # Lange HC, Heijnen JJ: Statistical reconciliation of the elemental 
    # and molecular biomass composition of Saccharomyces cerevisiae. 
    # Biotechnol Bioeng. 2001, 75: 334-344. 10.1002/bit.10054.

    # Szyperski T: Biosynthetically directed fractional 13C-labeling of proteinogenic amino acids.
    # An efficient analytical tool to investigate intermediary metabolism. 
    # Eur J Biochem. 1995, 232: 433-448. 10.1111/j.1432-1033.1995.tb20829.x.
    Pichia_pastoris = add_chemical(
        'Pichia_pastoris',
        phase='s',
        formula='CH1.761N0.143O0.636S0.0018',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Pichia_pastoris.Hf = chems.Glucose.Hf / chems.Glucose.MW * Pichia_pastoris.MW 
    # Same as glucose to ignore heats related to growth 

    K_marxianus = add_chemical(
        'K_marxianus',
        phase='s',
        formula = 'CH1.78O0.66N0.158P0.009S0.0035',#K0.0015',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    K_marxianus.Hf = chems.Glucose.Hf / chems.Glucose.MW * K_marxianus.MW
    # Same as glucose to ignore heats related to growth

    add_chemical('Glucan', phase='s')
    add_chemical('Mannoprotein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Chitin', search_ID='N-acetylglucosamine', phase='s')
    add_chemical('OleicAcid', phase='l', default=True)
    add_chemical('RNA', search_ID='Uracil', phase='s')

    add_chemical('Z_mobilis', formula="CH1.8O0.5N0.2",
                                    default=True, search_db=False,
                                    Hf=-31169.39*_cal2joule, phase='s')
    add_chemical('T_reesei', formula="CH1.645O0.445N0.205S0.005",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Biomass', formula="CH1.64O0.39N0.23S0.0035",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Cellulose', formula="C6H10O5", # Glucose monomer minus water
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-233200.06*_cal2joule,
                phase='s')
    add_chemical('Protein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Lignin', formula="C9H10O2", # A monomeric unit
                default=True, search_db=False,
                Hf=-182100*_cal2joule, phase='s')
    add_chemical('Enzyme', formula="CH1.59O0.42N0.24S0.01",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    # add_chemical('Glucan', formula='C6H10O5',
    #             Cp=Cp_cellulosic,
    #             default=True, search_db=False,
    #             Hf=-233200*_cal2joule,
    #             phase='s')
    add_chemical('Xylan', formula="C5H8O4",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-182100*_cal2joule,
                phase='s')
    add_chemical('Xylitol', formula="C5H12O5",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-243145*_cal2joule, phase='s')
    add_chemical('Cellobiose', formula="C12H22O11",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-480900*_cal2joule, phase='s')
    add_chemical('CSL', 
                formula='H2.8925O1.3275C1N0.0725S0.00175',
                default=True, search_db=False,
                Hf=(chems.Protein.Hf/4
                    + chems.H2O.Hf/2
                    + chems.LacticAcid.Hf/4), phase='s')
    append_chemical_copy('DenaturedEnzyme', chems.Enzyme)
    append_chemical_copy('WWTsludge', chems.Biomass)
    append_chemical_copy('Cellulase', chems.Enzyme)

    # heme molecule formula: C34H32FeN4O4
    # heme_b = add_chemical('heme')
    Heme_b = add_chemical('Heme_b', search_ID='PubChem=26945', phase='s', default=True)
    add_chemical('VitaminC', search_ID='AscorbicAcid', phase='s', default=True)

    # Only protein: 144 amino acids Formula:C729H1166N200O219S2​
    # https://www.uniprot.org/uniprotkb/P02236/entry#sequences
    protein_formula = {
        'H': 1166 / 729,
        'C': 729 / 729,
        'N': 200 / 729,
        'O': 219 / 729,
        'S': 2 / 729
    }
    # protein_formula = {
    #     'H': Fraction(1166,729) ,
    #     'C': Fraction(729,729) ,
    #     'N': Fraction(200,729) ,
    #     'O': Fraction(219,729) ,
    #     'S': Fraction(2,729)
    # }
    formula = {i: round(j, 6) for i, j in protein_formula.items()}
    Globin = add_chemical(
        'Globin',
        search_db=False,
        default=True,
        atoms=formula,
        phase='s'
    )
    Leghemoglobin_formula = {
        'H': (1166+32) / (729+34),
        'C': (729+34) / (729+34),
        'N': (200 +4) / (729+34),
        'O': (219+4) / (729+34),
        'S': 2 / (729+34),
        'Fe': 1 / (729+34)
    }
    formula2 = {i: round(j, 6) for i, j in Leghemoglobin_formula.items()}
    Leghemoglobin = add_chemical(
        'Leghemoglobin',
        search_db=False,
        default=True,
        atoms=formula2,
        phase='s',
        aliases=['LegH']
    )
    append_chemical_copy('Leghemoglobin_In', Leghemoglobin)
    append_chemical_copy('Globin_In', Globin)

    # Default missing properties of chemicals to those of water
    for chemical in chems: chemical.default()

    #################
    ##### Group #####
    #################
    chems.compile()
    chems.set_synonym('H2SO4', 'SulfuricAcid')
    chems.set_synonym('NH3', 'Ammonia')
    chems.set_synonym('H2O', 'Water')
    chems.set_synonym('Pichia_pastoris','cellmass')
    chems.set_synonym('(NH4)2HPO4','DAP')
    chems.set_synonym('Leghemoglobin','LegH')
    chems.set_synonym('Ethanol','EtOH')
    TMS = np.array([5*0.33, 2, 2.2, 1.5, 0.25, 0.5, 0.23, 0.47])*np.array([0.37,1,0.5614,0.6264,0.54557,0.6392,0.9417,0.5276])
    TMS_list = TMS.tolist()
    chems.define_group(
        'TraceMetalSolution',
        ['HCl','CaCl2','ZnSO4','MnSO4','CoCl2','CuSO4','(NH4)6Mo7O24','Na2B4O7','H2O'],
        TMS_list + [(1000 - sum(TMS_list))],
        wt=True
    )
    # 50mg/L Vitamin C Solution
    chems.define_group(
        'VitaminCSolution',
        ['VitaminC','H2O'],
        [0.05, (1000 - 0.05)],
        wt=True
    )
    
    chems.define_group(
        'air',
        ['O2', 'N2'],
        [28, 72],
        wt=True
    )

    # 16hour 150ml
    chems.define_group(
        'SeedSolution',
        ['H2O','(NH4)2SO4','Glucose','MgSO4','KH2PO4'],
        [100, 0.5, 1, 0.05, 0.3],
        wt=True
    )
    
    chems.define_group(
        'Seed',
        ['(NH4)2SO4','Glucose','MgSO4','KH2PO4'],
        [0.5, 1, 0.05, 0.3],
        wt=True
    )

    # 1.5 L
    chems.define_group(
        'CultureSolution',
        ['SeedSolution','Glycine','Glucose','FeSO4'],
        [1000, 0.1, 60, 0.15191],
        wt=True
    )

    chems.define_group(
        'Culture',
        ['Glycine','Glucose','FeSO4'],
        [0.1, 60, 0.15191],
        wt=True
    )

    # 25wt%NH3
    chems.define_group(
        'NH3_25wt',
        ['NH3','H2O'],
        [25,75],
        wt=True
    )

    # chems.define_group(
    #     'BufferA',
    #     ['H2O','(NH4)2HPO4','NaCl','EDTA'],
    #     [1000, 0.25*bst.Chemical('(NH4)2HPO4', phase='l', default=True).MW, 
    #     0.1*bst.Chemical('NaCl', phase='l', default=True).MW,
    #     0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
    #     wt=True,
    # )
    chems.define_group(
        'DfUltraBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )

    # chems.define_group(
    #     'BufferB',
    #     ['H2O','(NH4)2HPO4','NaCl','KCl'],
    #     [1000, 0.25*bst.Chemical('(NH4)2HPO4', phase='l', default=True).MW, 
    #     0.9*bst.Chemical('NaCl', phase='l', default=True).MW,
    #     0.1*bst.Chemical('KCl', phase='l', default=True).MW],
    #     wt=True,
    # )
    chems.define_group(
        'IXEquilibriumBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )
    chems.define_group(
        'IXElutionBuffer',
        ['KH2PO4','NaCl','KCl'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        1.0*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.01*bst.Chemical('KCl', phase='l', default=True).MW],
        wt=True,
    )

    # chems.define_group(
    #     'IXRegenerationSolution',
    #     ['KH2PO4','NaCl','KCl'],
    #     [0.25*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
    #     0.9*bst.Chemical('NaCl', phase='l', default=True).MW,
    #     0.1*bst.Chemical('KCl', phase='l', default=True).MW],
    #     wt=True,
    # )

    # chems.define_group(
    #     'BufferC',
    #     ['H2O','K2HPO4','KH2PO4','TrehaloseDH','SodiumAscorbate'],
    #     [1000, 0.01*bst.Chemical('K2HPO4', phase='l', default=True).MW, 
    #     0.01*bst.Chemical('KH2PO4', phase='l', default=True).MW,
    #     5,#0.25*bst.Chemical('TrehaloseDH',search_ID='6138-23-4', phase='l', default=True).MW,# 0.25
    #     0.005*bst.Chemical('SodiumAscorbate',search_ID='134-03-2', phase='l', default=True).MW],
    #     wt=True,
    # )

    # chems.define_group(
    #     'BufferC',
    #     ['H2O','K2HPO4','KH2PO4'],
    #     [1000, 0.01*bst.Chemical('K2HPO4', phase='l', default=True).MW, 
    #     0.01*bst.Chemical('KH2PO4', phase='l', default=True).MW],
    #     wt=True,
    # )

    chems.define_group(
        'DfNanoBuffer',
        ['Na2HPO4','NaH2PO4'],
        [0.01*bst.Chemical('Na2HPO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaH2PO4', phase='l', default=True).MW],
        wt=True,
    )

    if bst.settings.set_thermo: bst.settings.set_thermo(chems)
    return chems

# %%

def create_chemicals_Hemodextrin():
    ##############################################
    ##### set function of create new chemical ####
    ##############################################    
    chems = bst.Chemicals([])

    def add_chemical(ID, source=None, Cp=None, **data):
        chemical = tmo.Chemical.blank(ID, **data)
        if source: 
            default_phase_ref = source.phase_ref
            chemical.copy_models_from(source)
        else:
            default_phase_ref = 'l'
        if not chemical.phase_ref:
            chemical.phase_ref = default_phase_ref
        chemical.at_state(chemical.phase_ref)
        if Cp is not None: set_Cp(chemical, Cp)
        chemical.default()
        chems.append(chemical)

    def append_chemical(ID, search_ID=None, **data):
        chemical = tmo.Chemical(ID, search_ID=search_ID, **data)
        try: chemical.at_state(phase=chemical.phase_ref)
        except: pass
        chemical.default()    
        chems.append(chemical)
    
    def extend_chemical(IDs, **data):
        for ID in IDs: append_chemical(ID, **data)
    
    def append_chemical_copy(ID, chemical):
        new_chemical = chemical.copy(ID)
        chems.append(new_chemical)
    
    def set_Cp(single_phase_chemical, Cp):
        chem = single_phase_chemical
        chem.Cn.add_model(Cp * chem.MW, top_priority=True)
    
    def set_rho(single_phase_chemical, rho):
        V = fn.rho_to_V(rho, single_phase_chemical.MW)
        single_phase_chemical.V.add_model(V, top_priority=True)   

    def add_chemical(ID, ref=None, **data):
        chemical = bst.Chemical(ID, **data) if ref is None else ref.copy(ID, **data)
        chems.append(chemical)
        return chemical
    
    #########################
    #### Define Species #####
    #########################
    
    ##### General Liquid #####
    add_chemical('H2O', phase='l', default=True)
    add_chemical('H2SO4', phase='l',default=True)

    #### Gases ####
    add_chemical('O2', phase='g', Hf=0)
    add_chemical('N2', phase='g', Hf=0)
    add_chemical('CH4', phase='g')
    add_chemical('CO', search_ID='CarbonMonoxide', phase='g', Hf=-26400*_cal2joule)
    add_chemical('CO2', phase='g')
    add_chemical('NH3', phase='g', Hf=-10963*_cal2joule)
    add_chemical('NO', search_ID='NitricOxide', phase='g',formula='NO', Hf=82.05)
    add_chemical('NO2', phase='g', formula='NO2', Hf=7925*_cal2joule)
    add_chemical('H2S', phase='g', Hf=-4927*_cal2joule)
    add_chemical('SO2', phase='g')

    ##### Soluble inorganics #####
    add_chemical('KOH', phase='l', default=True)
    add_chemical('NaOH', phase='l', default=True)
    add_chemical('NaCl', phase='l', default=True)
    add_chemical('KCl', phase='l', default=True)

    add_chemical('(NH4)2SO4', phase='l', default=True, Hf=-288994*_cal2joule,aliases=['AmmoniumSulfate'])
    add_chemical('FeSO4', phase='l', default=True)
    add_chemical('MgSO4', phase='l', default=True) # 0.0001 $/kg
    Na2SO4 = add_chemical('Na2SO4', phase='l', default=True)
    Na2SO4.V.add_model(fn.rho_to_V(rho=2664, MW=Na2SO4.MW), top_priority=True)  # Density of solid Na2SO4
    
    NaHSO4 = add_chemical('NaHSO4', phase='l', default=True)
    NaHSO4.V.add_model(fn.rho_to_V(rho=2435, MW=NaHSO4.MW), top_priority=True)  # Density of solid NaHSO4

    add_chemical('KH2PO4', phase='l', default=True)
    add_chemical('K2HPO4', phase='l', default=True)
    add_chemical('NaH2PO4', phase='l', default=True)
    add_chemical('Na2HPO4', phase='l', default=True)
    add_chemical('(NH4)2HPO4', phase='l', default=True)
    
    # trace_metal_solution
    add_chemical('HCl', phase='l', default=True)
    add_chemical('CaCl2', phase='l', default=True)
    add_chemical('ZnSO4', phase='l', default=True)
    add_chemical('MnSO4', phase='l', default=True)
    add_chemical('CoCl2', phase='l', default=True)
    add_chemical('CuSO4', phase='l', default=True)
    add_chemical('(NH4)6Mo7O24', search_ID='PubChem=61578', phase='l', default=True)
    add_chemical('Na2B4O7', phase='l', default=True)

    #### Main Organic ####
    add_chemical('Glycine', phase='s')
    add_chemical('CitricAcid', phase='l', default=True)
    add_chemical('AceticAcid', phase='l', default=True)
    add_chemical('LacticAcid', phase='l', default=True)
    add_chemical('Glucose', phase='s', default=True)
    add_chemical('Sucrose', phase='s', default=True)
    add_chemical('Dextrose', phase='l', default=True)
    add_chemical('IPTG', phase='l', default=True)
    #add_chemical('Tryptone', phase='l', default=True)
    add_chemical('Ethanol', phase='l', default=True)
    add_chemical('Glycerol', phase='s', default=True)
    add_chemical('SuccinicAcid', phase='s', default=True)
    add_chemical('EDTA', phase='s', default=True)
    add_chemical('Trehalose', search_ID='PubChem=7427', phase='s', default=True)
    add_chemical('TrehaloseDH', search_ID='6138-23-4', phase='s', default=True)
    add_chemical('SodiumAscorbate', search_ID='134-03-2', phase='s', default=True)

    # antibiotics   
    add_chemical('Ampicillin', phase='l', default=True)
    add_chemical('Kanamycin', phase='l', default=True)
    add_chemical('Streptomycin', phase='l', default=True)
    add_chemical('Chloramphenicol', phase='l', default=True)
    
    CaSO4 = add_chemical('CaSO4', phase='s', default=True)
    CaO = add_chemical('CaO', phase='s', default=True)
    soluble_solids = [CaO]
    Ash=add_chemical('Ash',MW=1.,search_db=False) # Dummy chemical for ash
    P4010 = add_chemical('P4O10',phase = 'l',Hf=-582000*_cal2joule) # For phosphate precipitation
    insoluble_solids = [Ash, P4010]

    for chemical in insoluble_solids:
        V = fn.rho_to_V(rho=1540, MW=chemical.MW)
        try: chemical.V.s.add_model(V, top_priority=True)
        except: pass
    for chemical in soluble_solids:
        V = fn.rho_to_V(rho=1e5, MW=chemical.MW)
        try: chemical.V.add_model(V, top_priority=True)
        except: pass

    Ash.Cn.s.add_method(0.09 * 4.184 * Ash.MW) # Heat capacity model
    
    # Add missing thermodynamic properties for ash
    Ash.Psat.add_method(1e-10)
    Ash.Tb = 3000  # High boiling point for solid
    Ash.Hvap.add_method(0)

    Ash.get_missing_properties()

    #############
    #### Bio ####
    #############

    Yeast = add_chemical(
        'Yeast',
        phase='s',
        formula='CH1.61O0.56',#N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        #aliases=['Cellmass'],
    )
    Yeast.Hf = chems.Glucose.Hf / chems.Glucose.MW * Yeast.MW 
    # Same as glucose to ignore heats related to growth 

    # https://microbialcellfactories.biomedcentral.com/articles/10.1186/1475-2859-11-57/tables/2?utm_source=chatgpt.com
    # Lange HC, Heijnen JJ: Statistical reconciliation of the elemental 
    # and molecular biomass composition of Saccharomyces cerevisiae. 
    # Biotechnol Bioeng. 2001, 75: 334-344. 10.1002/bit.10054.

    # Szyperski T: Biosynthetically directed fractional 13C-labeling of proteinogenic amino acids.
    # An efficient analytical tool to investigate intermediary metabolism. 
    # Eur J Biochem. 1995, 232: 433-448. 10.1111/j.1432-1033.1995.tb20829.x.
    Pichia_pastoris = add_chemical(
        'Pichia_pastoris',
        phase='s',
        formula='CH1.761N0.143O0.636S0.0018',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Pichia_pastoris.Hf = chems.Glucose.Hf / chems.Glucose.MW * Pichia_pastoris.MW 
    # Same as glucose to ignore heats related to growth 

    K_marxianus = add_chemical(
        'K_marxianus',
        phase='s',
        formula = 'CH1.78O0.66N0.158P0.009S0.0035K0.0015',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    K_marxianus.Hf = chems.Glucose.Hf / chems.Glucose.MW * K_marxianus.MW
    # Same as glucose to ignore heats related to growth
    
    Bacillus_subtilis = add_chemical(
        'Bacillus_subtilis',
        phase='s',
        formula='CH1.80O0.50N0.20P0.018S0.005',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Bacillus_subtilis.Hf = chems.Glucose.Hf / chems.Glucose.MW * Bacillus_subtilis.MW 
    # Same as glucose to ignore heats related to growth 
    
    Saccharomyces_cerevisiae = add_chemical(
        'Saccharomyces_cerevisiae',
        phase='s',
        formula='CH1.79OO0.57N0.15P0.011S0.003', #Adapted from Lange and Heijnen (2001)  https://doi.org/10.1002/bit.10054
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Saccharomyces_cerevisiae.Hf = chems.Glucose.Hf / chems.Glucose.MW * Saccharomyces_cerevisiae.MW 
    # Same as glucose to ignore heats related to growth     
    
    Corynebacterium_glutamicum = add_chemical(
        'Corynebacterium_glutamicum',
        phase='s',
        formula='CH1.78OO0.43N0.22',#P0.019S0.004', #such as iCg2505 or the Marx/Wendisch models https://link.springer.com/article/10.1186/1475-2859-8-43
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Corynebacterium_glutamicum.Hf = chems.Glucose.Hf / chems.Glucose.MW * Corynebacterium_glutamicum.MW 

    add_chemical('Glucan', phase='s')
    add_chemical('Mannoprotein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Chitin', search_ID='N-acetylglucosamine', phase='s')
    add_chemical('OleicAcid', phase='l', default=True)
    add_chemical('RNA', search_ID='Uracil', phase='s')

    add_chemical('Z_mobilis', formula="CH1.8O0.5N0.2",
                                    default=True, search_db=False,
                                    Hf=-31169.39*_cal2joule, phase='s')
    add_chemical('T_reesei', formula="CH1.645O0.445N0.205S0.005",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Biomass', formula="CH1.64O0.39N0.23S0.0035",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Cellulose', formula="C6H10O5", # Glucose monomer minus water
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-233200.06*_cal2joule,
                phase='s')
    add_chemical('Protein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Lignin', formula="C9H10O2", # A monomeric unit
                default=True, search_db=False,
                Hf=-182100*_cal2joule, phase='s')
    add_chemical('Enzyme', formula="CH1.59O0.42N0.24S0.01",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    # add_chemical('Glucan', formula='C6H10O5',
    #             Cp=Cp_cellulosic,
    #             default=True, search_db=False,
    #             Hf=-233200*_cal2joule,
    #             phase='s')
    add_chemical('Xylan', formula="C5H8O4",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-182100*_cal2joule,
                phase='s')
    add_chemical('Xylitol', formula="C5H12O5",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-243145*_cal2joule, phase='s')
    add_chemical('Cellobiose', formula="C12H22O11",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-480900*_cal2joule, phase='s')
    add_chemical('CSL', 
                formula='H2.8925O1.3275C1N0.0725S0.00175',
                default=True, search_db=False,
                Hf=(chems.Protein.Hf/4
                    + chems.H2O.Hf/2
                    + chems.LacticAcid.Hf/4), phase='s')
    append_chemical_copy('DenaturedEnzyme', chems.Enzyme)
    append_chemical_copy('WWTsludge', chems.Biomass)
    append_chemical_copy('Cellulase', chems.Enzyme)

    # heme molecule formula: C34H32FeN4O4
    # heme_b = add_chemical('heme')
    Heme_b = add_chemical('Heme_b', search_ID='PubChem=26945', phase='s', default=True)
    append_chemical_copy('Heme_b_In', Heme_b)
    PPIX = add_chemical('ProtoporphyrinIX', search_ID='PubChem=4971', phase='s', default=True)
    append_chemical_copy('ProtoporphyrinIX_In', PPIX)
    
    add_chemical('Nicotinamide', default=True)
    add_chemical('L-Cysteine', default=True)
    #add_chemical('Cyclodextrin',search_ID="79647-56-6",default=True 7C)search_ID='PubChem=320760' 6C)
    Cyclodextrin = add_chemical('Cyclodextrin',formula='C42H70O35',
                default=True, search_db=False, Tm=774, phase='s')
    #Cyclodextrin.V.add_model(fn.rho_to_V(rho=1580, MW=Cyclodextrin.MW), top_priority=True)
    # add_chemical('Tryptone', formula="CH1.6O0.31N0.25S0.006",#CH1.551O0.331N0.239S0.0057
    #             default=True, search_db=False,
    #             Hf=-17618*_cal2joule, phase='s')
    add_chemical('Peptone', formula="CH1.85O0.50N0.23S0.004",#CH1.556O0.362N0.321S0.0025
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('VitaminC', search_ID='AscorbicAcid', phase='s', default=True)
    
    YeastExtract = add_chemical(
        'YeastExtract',
        phase='s',
        formula='CH1.61O0.56N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        #aliases=['Cellmass'],
    )
    YeastExtract.Hf = chems.Glucose.Hf / chems.Glucose.MW * YeastExtract.MW 
    
    
    # hemin molecule formula: C34H32ClFeN4O4
    #Hemin = add_chemical('Hemin', search_ID='PubChem=16129778', phase='s', default=True)
    
    
    # Default missing properties of chemicals to those of water
    for chemical in chems: chemical.default()

    #################
    ##### Group #####
    #################
    chems.compile()
    chems.set_synonym('H2SO4', 'SulfuricAcid')
    chems.set_synonym('NH3', 'Ammonia')
    chems.set_synonym('H2O', 'Water')
    # chems.set_synonym('Saccharomyces_cerevisiae','cellmass')
    # chems.set_synonym('Saccharomyces_cerevisiae','S_cerevisiae')
    chems.set_synonym('(NH4)2HPO4','DAP')
    #chems.set_synonym('Leghemoglobin','LegH')
    chems.set_synonym('Heme_b','Heme')
    chems.set_synonym('Ethanol','EtOH')

    TMS = np.array([5*0.33, 2, 2.2, 1.5, 0.25, 0.5, 0.23, 0.47])*np.array([0.37,1,0.5614,0.6264,0.54557,0.6392,0.9417,0.5276])
    TMS_list = TMS.tolist()
    chems.define_group(
        'TraceMetalSolution',
        ['HCl','CaCl2','ZnSO4','MnSO4','CoCl2','CuSO4','(NH4)6Mo7O24','Na2B4O7','H2O'],
        TMS_list + [(1000 - sum(TMS_list))],
        wt=True
    )
    # 50mg/L Vitamin C Solution
    chems.define_group(
        'VitaminCSolution',
        ['VitaminC','H2O'],
        [0.05, (1000 - 0.05)],
        wt=True
    )
    
    chems.define_group(
        'air',
        ['O2', 'N2'],
        [28, 72],
        wt=True
    )

    # 16hour 150ml
    chems.define_group(
        'SeedSolution',
        ['H2O','(NH4)2SO4','Glucose','MgSO4','KH2PO4'],#'TraceMetalSolution','VitaminCSolution'],
        [100, 0.5, 1, 0.05, 0.3],#0.01,0.012],
        wt=True
    )
    
    chems.define_group(
        'Seed',
        ['(NH4)2SO4','Glucose','MgSO4','KH2PO4'],#'TraceMetalSolution','VitaminCSolution'],
        [0.5, 1, 0.05, 0.3],#0.01,0.012],
        wt=True
    )

    # 1.5 L
    chems.define_group(
        'CultureSolution',
        ['SeedSolution','Glycine','Glucose','FeSO4'],#'TraceMetalSolution','VitaminCSolution'],
        [1000, 0.1, 60, 0.15191],#0.01,0.012],
        wt=True
    )

    chems.define_group(
        'Culture',
        ['Glycine','Glucose','FeSO4'],#'TraceMetalSolution','VitaminCSolution'],
        [0.1, 60, 0.15191],#0.01,0.012],
        wt=True
    )

    # 25wt%NH3
    chems.define_group(
        'NH3_25wt',
        ['NH3','H2O'],
        [25,75],
        wt=True
    )

    
    chems.define_group(
        'RAWash',
        ['Water', 'NaCl'],
        [0.998, 0.002],
        wt=True,
    )
    
    # 40C
    chems.define_group(
        'RAElution',
        ['Water', 'NaOH'],
        [1000, 
         0.5 * bst.Chemical('NaOH', phase='l', default=True).MW],
        wt=True,
    )
    
    chems.define_group(
        'RARegeneration',
        ['Water', 'Ethanol'],
        [0.30, 0.70],
        wt=True,
    )
    
    chems.define_group(
        'DfUltraBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )

    chems.define_group(
        'IXEquilibriumBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )
    chems.define_group(
        'IXElutionBuffer',
        ['KH2PO4','NaCl','KCl'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        1.0*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.01*bst.Chemical('KCl', phase='l', default=True).MW],
        wt=True,
    )

    chems.define_group(
        'DfNanoBuffer',
        ['Na2HPO4','NaH2PO4'],
        [0.01*bst.Chemical('Na2HPO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaH2PO4', phase='l', default=True).MW],
        wt=True,
    )

    # # Dried YPD
    # chems.define_group(
    #     'YPD',
    #     ['YeastExtract','Peptone','Glucose'],
    #     [10,20,20],
    #     wt=True
    # )
    # # single colony 18 hr 5 ml 30C 220 rpm 
    # # 1st precultur 14 hr 15 ml 30C 220 rpm in 250 ml flask
    # # 2nd precultur 24 hr 100 ml 30C 220 rpm in 500 ml flask
    # # 10% (vol/vol) of the seed cultures were inoculated into a 5 L bioreactor (Bai Lun, China) with 3 L of medium.
    
    # # YPD Medium
    # chems.define_group(
    #     'YPD_Medium',
    #     ['YeastExtract','Peptone','Glucose','H2O'],
    #     [10,20,20,(1000-10-20-20)],
    #     wt=True
    # )
    
    # # Dried Supplemented
    # chems.define_group(
    #     'Supplemented',
    #     ['KH2PO4','MgSO4','ZnSO4','TraceMetalSolution','VitaminCSolution'],
    #     [8,3,0.72*0.5614,10,12],
    #     wt=True
    # )
    
    # # pH 5 30C
    # # feed 5 M NH3 to maintain pH
    # # The air flow ranged from 1 vvm to 2 vvm (air volume/working volume/min) and the dissolved oxygen concentration
    # # (dO2) was controlled above 40% saturation using an agitation cascade (200–850 rpm).
    # # Supplemented Medium
    # chems.define_group(
    #     'Fermentation_Medium',
    #     ['KH2PO4','MgSO4','ZnSO4','TraceMetalSolution','VitaminCSolution','YPD_Medium'],
    #     [8,3,0.72*0.5614,10,12,(1000-8-3-0.72*0.5614-10-12)],
    #     wt=True
    # )

    # # 1st-stage Feed
    # chems.define_group(
    #     'Feed1st',
    #     ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone'],
    #     [500,9,2.5,3.5,0.28, 10, 12,10,20],
    #     wt=True
    # )
    # chems.define_group(
    #     'Feed1st_Solution',
    #     ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone','H2O'],
    #     [500,9,2.5,3.5,0.28, 10, 12,10,20,1000],
    #     wt=True
    # )
    
    # # 2nd-stage Feed
    # chems.define_group(
    #     'Feed2nd',
    #     ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone'],
    #     [800,9,2.5,3.5,0.28, 10, 12,10,20],
    #     wt=True
    # )
    # chems.define_group(
    #     'Feed2nd_Solution',
    #     ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone','H2O'],
    #     [800,9,2.5,3.5,0.28, 10, 12,10,20,1000],
    #     wt=True
    # )
    
    
    if bst.settings.set_thermo: bst.settings.set_thermo(chems)
    return chems



# def create_chemicals_Hemodextrin():
#     ##############################################
#     ##### set function of create new chemical ####
#     ##############################################    
#     chems = bst.Chemicals([])

#     def add_chemical(ID, source=None, Cp=None, **data):
#         chemical = tmo.Chemical.blank(ID, **data)
#         if source: 
#             default_phase_ref = source.phase_ref
#             chemical.copy_models_from(source)
#         else:
#             default_phase_ref = 'l'
#         if not chemical.phase_ref:
#             chemical.phase_ref = default_phase_ref
#         chemical.at_state(chemical.phase_ref)
#         if Cp is not None: set_Cp(chemical, Cp)
#         chemical.default()
#         chems.append(chemical)

#     def append_chemical(ID, search_ID=None, **data):
#         chemical = tmo.Chemical(ID, search_ID=search_ID, **data)
#         try: chemical.at_state(phase=chemical.phase_ref)
#         except: pass
#         chemical.default()    
#         chems.append(chemical)
    
#     def extend_chemical(IDs, **data):
#         for ID in IDs: append_chemical(ID, **data)
    
#     def append_chemical_copy(ID, chemical):
#         new_chemical = chemical.copy(ID)
#         chems.append(new_chemical)
    
#     def set_Cp(single_phase_chemical, Cp):
#         chem = single_phase_chemical
#         chem.Cn.add_model(Cp * chem.MW, top_priority=True)
    
#     def set_rho(single_phase_chemical, rho):
#         V = fn.rho_to_V(rho, single_phase_chemical.MW)
#         single_phase_chemical.V.add_model(V, top_priority=True)   

#     def add_chemical(ID, ref=None, **data):
#         chemical = bst.Chemical(ID, **data) if ref is None else ref.copy(ID, **data)
#         chems.append(chemical)
#         return chemical
    
#     #########################
#     #### Define Species #####
#     #########################
    
#     ##### General Liquid #####
#     add_chemical('H2O', phase='l', default=True)
#     add_chemical('H2SO4', phase='l',default=True)
#     add_chemical('HCl', phase='l', default=True)

#     #### Gases ####
#     add_chemical('O2', phase='g', Hf=0)
#     add_chemical('N2', phase='g', Hf=0)
#     add_chemical('CH4', phase='g')
#     add_chemical('CO', search_ID='CarbonMonoxide', phase='g', Hf=-26400*_cal2joule)
#     add_chemical('CO2', phase='g')
#     add_chemical('NH3', phase='g', Hf=-10963*_cal2joule)
#     add_chemical('NO', search_ID='NitricOxide', phase='g',formula='NO', Hf=82.05)
#     add_chemical('NO2', phase='g', formula='NO2', Hf=7925*_cal2joule)
#     add_chemical('H2S', phase='g', Hf=-4927*_cal2joule)
#     add_chemical('SO2', phase='g')

#     ##### Soluble inorganics #####
#     add_chemical('KOH', phase='l', default=True)
#     add_chemical('NaOH', phase='l', default=True)
#     add_chemical('NaCl', phase='l', default=True)
#     add_chemical('KCl', phase='l', default=True)

#     add_chemical('(NH4)2SO4', phase='l', default=True, Hf=-288994*_cal2joule,aliases=['AmmoniumSulfate'])
#     add_chemical('FeSO4', phase='l', default=True)
#     add_chemical('MgSO4', phase='l', default=True) # 0.0001 $/kg
#     Na2SO4 = add_chemical('Na2SO4', phase='l', default=True)
#     Na2SO4.V.add_model(fn.rho_to_V(rho=2664, MW=Na2SO4.MW), top_priority=True)  # Density of solid Na2SO4
    
#     NaHSO4 = add_chemical('NaHSO4', phase='l', default=True)
#     NaHSO4.V.add_model(fn.rho_to_V(rho=2435, MW=NaHSO4.MW), top_priority=True)  # Density of solid NaHSO4

#     add_chemical('KH2PO4', phase='l', default=True)
#     add_chemical('K2HPO4', phase='l', default=True)
#     add_chemical('NaH2PO4', phase='l', default=True)
#     add_chemical('Na2HPO4', phase='l', default=True)
#     add_chemical('(NH4)2HPO4', phase='l', default=True)
    
#     # trace_metal_solution
#     add_chemical('HCl', phase='l', default=True)
#     add_chemical('CaCl2', phase='l', default=True)
#     add_chemical('ZnSO4', phase='l', default=True)
#     add_chemical('MnSO4', phase='l', default=True)
#     add_chemical('CoCl2', phase='l', default=True)
#     add_chemical('CuSO4', phase='l', default=True)
#     add_chemical('(NH4)6Mo7O24', search_ID='PubChem=61578', phase='l', default=True)
#     add_chemical('Na2B4O7', phase='l', default=True)

#     #### Main Organic ####
#     add_chemical('Glycine', phase='s')
#     add_chemical('CitricAcid', phase='l', default=True)
#     add_chemical('AceticAcid', phase='l', default=True)
#     add_chemical('LacticAcid', phase='l', default=True)
#     add_chemical('Glucose', phase='s', default=True)
#     add_chemical('Surcose', phase='s', default=True)
#     add_chemical('Dextrose', phase='l', default=True)
#     add_chemical('IPTG', phase='l', default=True)
#     #add_chemical('Tryptone', phase='l', default=True)
#     add_chemical('Ethanol', phase='l', default=True)
#     add_chemical('Glycerol', phase='s', default=True)
#     add_chemical('SuccinicAcid', phase='s', default=True)
#     add_chemical('EDTA', phase='s', default=True)
#     add_chemical('Trehalose', search_ID='PubChem=7427', phase='s', default=True)
#     add_chemical('TrehaloseDH', search_ID='6138-23-4', phase='s', default=True)
#     add_chemical('SodiumAscorbate', search_ID='134-03-2', phase='s', default=True)

#     # antibiotics   
#     add_chemical('Ampicillin', phase='l', default=True)
#     add_chemical('Kanamycin', phase='l', default=True)
#     add_chemical('Streptomycin', phase='l', default=True)
#     add_chemical('Chloramphenicol', phase='l', default=True)
    
#     CaSO4 = add_chemical('CaSO4', phase='s', default=True)
#     CaO = add_chemical('CaO', phase='s', default=True)
#     soluble_solids = [CaO]
#     Ash=add_chemical('Ash',MW=1.,search_db=False) # Dummy chemical for ash
#     P4010 = add_chemical('P4O10',phase = 'l',Hf=-582000*_cal2joule) # For phosphate precipitation
#     insoluble_solids = [Ash, P4010]

#     for chemical in insoluble_solids:
#         V = fn.rho_to_V(rho=1540, MW=chemical.MW)
#         try: chemical.V.s.add_model(V, top_priority=True)
#         except: pass
#     for chemical in soluble_solids:
#         V = fn.rho_to_V(rho=1e5, MW=chemical.MW)
#         try: chemical.V.add_model(V, top_priority=True)
#         except: pass

#     Ash.Cn.s.add_method(0.09 * 4.184 * Ash.MW) # Heat capacity model
    
#     # Add missing thermodynamic properties for ash
#     Ash.Psat.add_method(1e-10)
#     Ash.Tb = 3000  # High boiling point for solid
#     Ash.Hvap.add_method(0)

#     Ash.get_missing_properties()

#     #############
#     #### Bio ####
#     #############

#     Yeast = add_chemical(
#         'Yeast',
#         phase='s',
#         formula='CH1.61O0.56',#N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         #aliases=['Cellmass'],
#     )
#     Yeast.Hf = chems.Glucose.Hf / chems.Glucose.MW * Yeast.MW 
#     # Same as glucose to ignore heats related to growth 

#     # https://microbialcellfactories.biomedcentral.com/articles/10.1186/1475-2859-11-57/tables/2?utm_source=chatgpt.com
#     # Lange HC, Heijnen JJ: Statistical reconciliation of the elemental 
#     # and molecular biomass composition of Saccharomyces cerevisiae. 
#     # Biotechnol Bioeng. 2001, 75: 334-344. 10.1002/bit.10054.

#     # Szyperski T: Biosynthetically directed fractional 13C-labeling of proteinogenic amino acids.
#     # An efficient analytical tool to investigate intermediary metabolism. 
#     # Eur J Biochem. 1995, 232: 433-448. 10.1111/j.1432-1033.1995.tb20829.x.
#     Pichia_pastoris = add_chemical(
#         'Pichia_pastoris',
#         phase='s',
#         formula='CH1.761N0.143O0.636S0.0018',
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         # aliases=['Cellmass'],
#     )
#     Pichia_pastoris.Hf = chems.Glucose.Hf / chems.Glucose.MW * Pichia_pastoris.MW 
#     # Same as glucose to ignore heats related to growth 

#     K_marxianus = add_chemical(
#         'K_marxianus',
#         phase='s',
#         formula = 'CH1.78O0.66N0.158P0.009S0.0035K0.0015',
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         # aliases=['Cellmass'],
#     )
#     K_marxianus.Hf = chems.Glucose.Hf / chems.Glucose.MW * K_marxianus.MW
#     # Same as glucose to ignore heats related to growth
    
#     Bacillus_subtilis = add_chemical(
#         'Bacillus_subtilis',
#         phase='s',
#         formula='CH1.80O0.50N0.20P0.018S0.005',
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         # aliases=['Cellmass'],
#     )
#     Bacillus_subtilis.Hf = chems.Glucose.Hf / chems.Glucose.MW * Bacillus_subtilis.MW 
#     # Same as glucose to ignore heats related to growth 
    
#     Saccharomyces_cerevisiae = add_chemical(
#         'Saccharomyces_cerevisiae',
#         phase='s',
#         formula='CH1.79OO0.57N0.15P0.011S0.003', #Adapted from Lange and Heijnen (2001)  https://doi.org/10.1002/bit.10054
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         # aliases=['Cellmass'],
#     )
#     Saccharomyces_cerevisiae.Hf = chems.Glucose.Hf / chems.Glucose.MW * Saccharomyces_cerevisiae.MW 
#     # Same as glucose to ignore heats related to growth     

#     add_chemical('Glucan', phase='s')
#     add_chemical('Mannoprotein', formula="CH1.57O0.31N0.29S0.007",
#                 default=True, search_db=False,
#                 Hf=-17618*_cal2joule, phase='s')
#     add_chemical('Chitin', search_ID='N-acetylglucosamine', phase='s')
#     add_chemical('OleicAcid', phase='l', default=True)
#     add_chemical('RNA', search_ID='Uracil', phase='s')

#     add_chemical('Z_mobilis', formula="CH1.8O0.5N0.2",
#                                     default=True, search_db=False,
#                                     Hf=-31169.39*_cal2joule, phase='s')
#     add_chemical('T_reesei', formula="CH1.645O0.445N0.205S0.005",
#                 default=True, search_db=False,
#                 Hf=-23200.01*_cal2joule, phase='s')
#     add_chemical('Biomass', formula="CH1.64O0.39N0.23S0.0035",
#                 default=True, search_db=False,
#                 Hf=-23200.01*_cal2joule, phase='s')
#     add_chemical('Cellulose', formula="C6H10O5", # Glucose monomer minus water
#                 Cp=Cp_cellulosic,
#                 default=True, search_db=False,
#                 Hf=-233200.06*_cal2joule,
#                 phase='s')
#     add_chemical('Protein', formula="CH1.57O0.31N0.29S0.007",
#                 default=True, search_db=False,
#                 Hf=-17618*_cal2joule, phase='s')
#     add_chemical('Lignin', formula="C9H10O2", # A monomeric unit
#                 default=True, search_db=False,
#                 Hf=-182100*_cal2joule, phase='s')
#     add_chemical('Enzyme', formula="CH1.59O0.42N0.24S0.01",
#                 default=True, search_db=False,
#                 Hf=-17618*_cal2joule, phase='s')
#     # add_chemical('Glucan', formula='C6H10O5',
#     #             Cp=Cp_cellulosic,
#     #             default=True, search_db=False,
#     #             Hf=-233200*_cal2joule,
#     #             phase='s')
#     add_chemical('Xylan', formula="C5H8O4",
#                 Cp=Cp_cellulosic,
#                 default=True, search_db=False,
#                 Hf=-182100*_cal2joule,
#                 phase='s')
#     add_chemical('Xylitol', formula="C5H12O5",
#                 Cp=Cp_cellulosic,
#                 default=True, search_db=False,
#                 Hf=-243145*_cal2joule, phase='s')
#     add_chemical('Cellobiose', formula="C12H22O11",
#                 Cp=Cp_cellulosic,
#                 default=True, search_db=False,
#                 Hf=-480900*_cal2joule, phase='s')
#     add_chemical('CSL', 
#                 formula='H2.8925O1.3275C1N0.0725S0.00175',
#                 default=True, search_db=False,
#                 Hf=(chems.Protein.Hf/4
#                     + chems.H2O.Hf/2
#                     + chems.LacticAcid.Hf/4), phase='s')
#     append_chemical_copy('DenaturedEnzyme', chems.Enzyme)
#     append_chemical_copy('WWTsludge', chems.Biomass)
#     append_chemical_copy('Cellulase', chems.Enzyme)

#     # heme molecule formula: C34H32FeN4O4
#     # heme_b = add_chemical('heme')
#     Heme_b = add_chemical('Heme_b', search_ID='PubChem=26945', phase='s', default=True)
#     Heme_b_In = append_chemical_copy('Heme_b_In', Heme_b)
#     PPIX = add_chemical('ProtoporphyrinIX', search_ID='PubChem=4971', phase='s', default=True)
#     add_chemical('Nicotinamide', default=True)
#     add_chemical('L-Cysteine', default=True)
#     #add_chemical('Cyclodextrin',search_ID="79647-56-6",default=True 7C)search_ID='PubChem=320760' 6C)
#     add_chemical('Cyclodextrin',formula='C42H70O35',
#                 default=True, search_db=False, Tm=774, density=1580, phase='s')
#     # add_chemical('Tryptone', formula="CH1.6O0.31N0.25S0.006",#CH1.551O0.331N0.239S0.0057
#     #             default=True, search_db=False,
#     #             Hf=-17618*_cal2joule, phase='s')
#     add_chemical('Peptone', formula="CH1.85O0.50N0.23S0.004",#CH1.556O0.362N0.321S0.0025
#                 default=True, search_db=False,
#                 Hf=-17618*_cal2joule, phase='s')
#     add_chemical('VitaminC', search_ID='AscorbicAcid', phase='s', default=True)
    
#     YeastExtract = add_chemical(
#         'YeastExtract',
#         phase='s',
#         formula='CH1.61O0.56N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
#         rho=1540,
#         Cp=chems.Glucose.Cp(298.15), # 1.54
#         default=True,
#         search_db=False,
#         #aliases=['Cellmass'],
#     )
#     YeastExtract.Hf = chems.Glucose.Hf / chems.Glucose.MW * YeastExtract.MW 
    
    
#     # hemin molecule formula: C34H32ClFeN4O4
#     Hemin = add_chemical('Hemin', search_ID='PubChem=16129778', phase='s', default=True)
    
    
#     # Default missing properties of chemicals to those of water
#     for chemical in chems: chemical.default()

#     #################
#     ##### Group #####
#     #################
#     chems.compile()
#     chems.set_synonym('H2SO4', 'SulfuricAcid')
#     chems.set_synonym('NH3', 'Ammonia')
#     chems.set_synonym('H2O', 'Water')
#     chems.set_synonym('Saccharomyces_cerevisiae','cellmass')
#     chems.set_synonym('Saccharomyces_cerevisiae','S_cerevisiae')
#     chems.set_synonym('(NH4)2HPO4','DAP')
#     chems.set_synonym('Leghemoglobin','LegH')
#     chems.set_synonym('Heme_b','Heme')

#     TMS = np.array([5*0.33, 2, 2.2, 1.5, 0.25, 0.5, 0.23, 0.47])*np.array([0.37,1,0.5614,0.6264,0.54557,0.6392,0.9417,0.5276])
#     TMS_list = TMS.tolist()
#     chems.define_group(
#         'TraceMetalSolution',
#         ['HCl','CaCl2','ZnSO4','MnSO4','CoCl2','CuSO4','(NH4)6Mo7O24','Na2B4O7','H2O'],
#         TMS_list + [(1000 - sum(TMS_list))],
#         wt=True
#     )
#     # 50mg/L Vitamin C Solution
#     chems.define_group(
#         'VitaminCSolution',
#         ['VitaminC','H2O'],
#         [0.05, (1000 - 0.05)],
#         wt=True
#     )
    
    
#     chems.define_group(
#         'air',
#         ['O2', 'N2'],
#         [28, 72],
#         wt=True
#     )

#     # Dried YPD
#     chems.define_group(
#         'YPD',
#         ['YeastExtract','Peptone','Glucose'],
#         [10,20,20],
#         wt=True
#     )
#     # single colony 18 hr 5 ml 30C 220 rpm 
#     # 1st precultur 14 hr 15 ml 30C 220 rpm in 250 ml flask
#     # 2nd precultur 24 hr 100 ml 30C 220 rpm in 500 ml flask
#     # 10% (vol/vol) of the seed cultures were inoculated into a 5 L bioreactor (Bai Lun, China) with 3 L of medium.
    
#     # YPD Medium
#     chems.define_group(
#         'YPD_Medium',
#         ['YeastExtract','Peptone','Glucose','H2O'],
#         [10,20,20,(1000-10-20-20)],
#         wt=True
#     )
    
#     # Dried Supplemented
#     chems.define_group(
#         'Supplemented',
#         ['KH2PO4','MgSO4','ZnSO4','TraceMetalSolution','VitaminCSolution'],
#         [8,3,0.72*0.5614,10,12],
#         wt=True
#     )
    
#     # pH 5 30C
#     # feed 5 M NH3 to maintain pH
#     # The air flow ranged from 1 vvm to 2 vvm (air volume/working volume/min) and the dissolved oxygen concentration
#     # (dO2) was controlled above 40% saturation using an agitation cascade (200–850 rpm).
#     # Supplemented Medium
#     chems.define_group(
#         'Fermentation_Medium',
#         ['KH2PO4','MgSO4','ZnSO4','TraceMetalSolution','VitaminCSolution','YPD_Medium'],
#         [8,3,0.72*0.5614,10,12,(1000-8-3-0.72*0.5614-10-12)],
#         wt=True
#     )

#     # 1st-stage Feed
#     chems.define_group(
#         'Feed1st',
#         ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone'],
#         [500,9,2.5,3.5,0.28, 10, 12,10,20],
#         wt=True
#     )
#     chems.define_group(
#         'Feed1st_Solution',
#         ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone','H2O'],
#         [500,9,2.5,3.5,0.28, 10, 12,10,20,1000],
#         wt=True
#     )
    
#     # 2nd-stage Feed
#     chems.define_group(
#         'Feed2nd',
#         ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone'],
#         [800,9,2.5,3.5,0.28, 10, 12,10,20],
#         wt=True
#     )
#     chems.define_group(
#         'Feed2nd_Solution',
#         ['Glucose','KH2PO4','MgSO4','K2SO4','Na2SO4','TraceMetalSolution','VitaminCSolution','YeastExtract','Peptone','H2O'],
#         [800,9,2.5,3.5,0.28, 10, 12,10,20,1000],
#         wt=True
#     )
    

#     # 25wt%NH3
#     chems.define_group(
#         'NH3_25wt',
#         ['NH3','H2O'],
#         [25,75],
#         wt=True
#     )

#     # air
#     chems.define_group(
#         'air',
#         ['O2','N2'],
#         [22,78],
#         wt=True
#     )

#     chems.define_group(
#         'DfUltraBuffer',
#         ['KH2PO4','NaCl','EDTA'],
#         [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
#         0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
#         0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
#         wt=True,
#     )

#     chems.define_group(
#         'IXEquilibriumBuffer',
#         ['KH2PO4','NaCl','EDTA'],
#         [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
#         0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
#         0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
#         wt=True,
#     )
#     chems.define_group(
#         'IXElutionBuffer',
#         ['KH2PO4','NaCl','KCl'],
#         [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
#         1.0*bst.Chemical('NaCl', phase='l', default=True).MW,
#         0.01*bst.Chemical('KCl', phase='l', default=True).MW],
#         wt=True,
#     )

#     chems.define_group(
#         'DfNanoBuffer',
#         ['Na2HPO4','NaH2PO4'],
#         [0.01*bst.Chemical('Na2HPO4', phase='l', default=True).MW, 
#         0.01*bst.Chemical('NaH2PO4', phase='l', default=True).MW],
#         wt=True,
#     )

#     if bst.settings.set_thermo: bst.settings.set_thermo(chems)
#     return chems





================ FILE: HemeIn\streams.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-05-07 18:26:22

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

from biosteam import stream_kwargs
from biorefineries.prefers._process_settings import price  # ADD THIS IMPORT
import biosteam as bst
from biosteam.units import Fermentation
from httpx import stream
import numpy as np
from sympy import Trace  # ADD THIS IMPORT
LegH={}


productivity = 4.2/1000 # [g / L / h]
tau = 162 # [h]
titer = productivity * tau # [g / L]
# OD600 180
# 1 OD600 = 0.35 g/L dry cell weight
LegH_yield = titer * 5 / 1300 # [by wt]

# 72 hours growth + 108 hours fermentation

m=2/5 # scale up factor based on 1.5e5 kg/yr
# %% In
# TraceMetalSolution = stream_kwargs('TraceMetalSolution', TraceMetalSolution=1, units='kg/hr', T=25+273.15)
# VitaminCSolution = stream_kwargs('VitaminCSolution', VitaminC=1, units='kg/hr', T=25+273.15)
# YPD = stream_kwargs('YPD', YPD_Medium=1, units='kg/hr', T=25+273.15)
# YPD_Medium = stream_kwargs('YPD_Medium', YPD_Medium=1, units='kg/hr', T=25+273.15)
# Supplemented = stream_kwargs('Supplemented', Supplemented=1, units='kg/hr', T=25+273.15)
# Fermentation_Medium = stream_kwargs('Supplemented_Medium', Fermentation_Medium=1, units='kg/hr', T=25+273.15)
# Feed1st = stream_kwargs('Feed1st', Fermentation_Medium=1, units='kg/hr', T=25+273.15)
# Feed2nd = stream_kwargs('Feed2nd', Fermentation_Medium=1, units='kg/hr', T=25+273.15)
# Feed1st_Solution = stream_kwargs('Feed1st_Solution', Fermentation_Medium=1, units='kg/hr', T=25+273.15)
# Feed2nd_Solution = stream_kwargs('Feed2nd_Solution', Fermentation_Medium=1, units='kg/hr', T=25+273.15)

SeedIn1 = stream_kwargs('SeedIn1', Seed=1, units='kg/hr', T=25+273.15)
SeedIn2 = stream_kwargs('SeedIn2', Seed=1, units='kg/hr', T=25+273.15)
CultureIn = stream_kwargs('CultureIn', Culture=1, units='kg/hr', T=25+273.15)
SeedSolution1 = stream_kwargs('SeedSolution1', SeedSolution=m*0.15*1e5/16, units='kg/hr', T=25+273.15)
SeedSolution2 = stream_kwargs('SeedSolution2', SeedSolution=m*1.5*1e5/16, units='kg/hr', T=25+273.15)
CultureSolution = stream_kwargs('CultureSolution', CultureSolution=m*1.5*1e5/16, units='kg/hr', T=25+273.15)

Glucose = stream_kwargs('Glucose', Glucose=m*1.3*1e5/72, units='kg/hr', T=25+273.15)
NH3_25wt = stream_kwargs('NH3_25wt', NH3_25wt=m*300, units='kg/hr', T=25+273.15)#, price=price['NH3_25wt'])

DfUltraBuffer = stream_kwargs('DfUltraBuffer', DfUltraBuffer=1, units='kg/hr', T=25+273.15)
IXEquilibriumBuffer = stream_kwargs('IXEquilibriumBuffer', IXEquilibriumBuffer=1, units='kg/hr', T=25+273.15)
IXElutionBuffer = stream_kwargs('IXElutionBuffer', IXElutionBuffer=1, units='kg/hr', T=25+273.15)
IXRegenerationSolution = stream_kwargs('IXRegenerationSolution', NaOH =1, units='kg/hr', T=25+273.15)
DfNanoBuffer = stream_kwargs('DfNanoBuffer', DfNanoBuffer=1, units='kg/hr', T=25+273.15)

# %% Out

LegH_1 = stream_kwargs('LegH_1')
LegH_2 = stream_kwargs('LegH_2')
LegH_3 = stream_kwargs('LegH_3',units='kg/hr', T=25+273.15, price = 20)#11.006028727167918)
vent1 = stream_kwargs('vent1')
vent2 = stream_kwargs('vent2')
effluent1 = stream_kwargs('effluent1')
effluent2 = stream_kwargs('effluent2', units='kg/hr', price=-0.33)  # organic waste remove
effluent3 = stream_kwargs('effluent3')


# %%
# Add missing pricing functions directly here since they're not in your _streams2.py
def set_stream_price_from_components(stream, chemical_prices=None):
    """Set stream price based on individual chemical component prices"""
    from biorefineries.prefers._process_settings import price
    if chemical_prices is None:
        chemical_prices = price
    
    try:
        # FIX: Check if stream is a proper Stream object
        if not hasattr(stream, 'imass'):
            print(f"Warning: {stream} is not a proper Stream object, skipping pricing")
            return 0
            
        mass = stream.imass
        total_cost = 0
        total_mass = stream.F_mass
        
        # Handle individual chemicals in groups
        for chemical_id in stream.chemicals.IDs:
            if mass[chemical_id] > 0:
                # Check if this is a grouped chemical with group composition
                chemical = stream.chemicals[chemical_id]
                if hasattr(chemical, '_group_wt_composition') and chemical._group_wt_composition:
                    # This is a group - calculate based on group composition
                    group_mass = mass[chemical_id]
                    for component_id, fraction in chemical._group_wt_composition.items():
                        if component_id in chemical_prices:
                            component_cost = group_mass * fraction * chemical_prices[component_id]
                            total_cost += component_cost
                else:
                    # Individual chemical
                    if chemical_id in chemical_prices:
                        total_cost += mass[chemical_id] * chemical_prices[chemical_id]
        
        stream.price = total_cost / total_mass if total_mass > 0 else 0
        return stream.price
        
    except Exception as e:
        print(f"Warning: Could not set price for {getattr(stream, 'ID', 'unknown')}: {e}")
        if hasattr(stream, 'price'):
            stream.price = 0
        return 0

def create_stream(stream_list):
    """Create a new stream with default properties"""
    streams = []
    for stream_kwargs in stream_list:
        s = bst.Stream(**stream_kwargs)
        streams.append(s)
    return streams

def update_all_input_stream_prices(streamlist):
    """Update prices for all input streams"""
    # FIX: Check if streams exist and are proper objects
    try:
        input_streams = streamlist
        # input_streams = create_stream([SeedIn, CultureIn, Glucose, NH3_25wt, 
        #                 BufferA, BufferB, BufferC])
        
        for stream in input_streams:
            # FIX: Verify each stream is a proper Stream object
            if hasattr(stream, 'imass') and hasattr(stream, 'ID'):
                old_price = getattr(stream, 'price', 0)
                new_price = set_stream_price_from_components(stream)
                print(f"{stream.ID}: ${old_price:.4f}/kg → ${new_price:.4f}/kg")
            else:
                print(f"Warning: Stream {stream} is not properly initialized")
    except Exception as e:
        print(f"Error updating stream prices: {e}")


================ FILE: HemeIn\system.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-12-04 13:25:17

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

#from biorefineries.animal_bedding import _system
from ast import Yield
from math import tau
import re
from altair import Y
from biorefineries.prefers.process_settings import set_GWPCF, GWP_CFs, set_GWPCF_Multi, load_process_settings
from biorefineries.prefers.HemeIn import streams as s
import biosteam as bst
from docutils import Component
from pint import set_application_registry
from regex import B, P
from thermosteam import Stream
from biosteam import F
import thermosteam as tmo
import numpy as np
from biorefineries.prefers.HemeIn import chemicals as c
from biorefineries.prefers import units as u
from biorefineries.prefers.process_settings import price

# %% Settings
bst.settings.set_thermo(c.create_chemicals_Hemodextrin(), skip_checks=True)
bst.preferences.classic_mode()

# %%
__all__ = (
    'create_Heme_system',
)
# %%
@bst.SystemFactory(
    ID='Heme_sys',
    ins=[s.SeedIn1, s.SeedIn2, s.CultureIn, s.Glucose,s.NH3_25wt,],
    outs=[s.vent1, s.vent2,
    ],
    fthermo=c.create_chemicals_Hemodextrin, # Pass the function itself
)
def create_Heme_system(
        ins, outs,
        use_area_convention=False,
        # reactions_passed=None, # Placeholder if reactions were to be passed externally
        # One could add more configurable parameters here:
        # V_max_fermenter=500, target_titer=7.27, etc.
    ):
    """
    Creates the Hemedextrin (Protein Free) production system.
    This system is based on the process flow and parameters from test_LegH.py.
    """
    bst.preferences.N=50
    
    # Unpack input streams
    SeedIn1, SeedIn2, CultureIn, Glucose, NH3_25wt = ins

    # Unpack output streams
    (vent1, vent2) = outs    
    
    ## LCA Settings ##
    
    load_process_settings()  # Load process settings to update prices and CFs
    """
    Fermentation Parameter
    """
    theta_O2 = 0.45 # Dissolved oxygen concentration [% saturation] >= 40%
    agitation_power = 0.985 # [kW / m3]
    design = 'Stirred tank' # Reactor type
    method = "Riet" # Name of method
    T_operation = 273.15 + 30 # [K]
    Q_O2_consumption = -110 * 4184 # [kJ/kmol]
    dT_hx_loop = 8 # [degC]
    cooler_pressure_drop = 20684 # [Pa]
    compressor_isentropic_efficiency = 0.85
    V_max = 500 # [m3] #here cause pressure vessel design problem

    # OD600 180
    # 1 OD600 = 0.35 g/L dry cell weight
    # first 10 hour, 10 g/L/h
    Glucose_Utilization = 0.5614 # [by wt] based on glucose fed
    # 72 hours growth + 90 hours fermentation
    # 1st    
    tau1= 72 # [h] growth time
    P_Heme_1st = 1e-8 # [g / L / h]
    P_pp_1st = 1e-8 # [g / L / h]
    P_ComsuptionG1 = 500 * (0.5/3) / tau1 # [g / L / h] glucose consumption rate
    P_cell_growth_rate1 = 150 * 0.35 / tau1 # [g / L / h] cell growth rate
    Y_Heme1 = P_Heme_1st / P_ComsuptionG1 # product yield on glucose
    Y_pp1 = P_pp_1st / P_ComsuptionG1 # proph
    Y_b1 = P_cell_growth_rate1 / P_ComsuptionG1 # biomass yield on glucose
    Y_r1 = 1 - Y_Heme1 - Y_pp1 - Y_b1 # respiration yield on glucose
    
    # 2nd
    tau2= 90 # [h] fermentation time
    P_Heme_2nd = 4.2/1e3 # [g / L / h]
    P_pp_2nd = 0.7/1e3 # [g / L / h]
    P_ComsuptionG2 = 800 * (0.5/3) / tau2 # [g / L / h] glucose consumption rate
    P_cell_growth_rate2 = 50 * 0.35 / tau2 # [g / L / h] cell growth rate
    Y_Heme2 = P_Heme_2nd / P_ComsuptionG2 # product yield on glucose
    Y_pp2 = P_pp_2nd / P_ComsuptionG2 # proph
    Y_b2 = P_cell_growth_rate2 / P_ComsuptionG2 # biomass yield on glucose
    Y_r2 = 1 - Y_Heme2 - Y_pp2 - Y_b2 # respiration yield on glucose
    
    # Overall
    tau = tau1 + tau2 # [h] total time
    P_Heme = (P_Heme_1st*tau1 + P_Heme_2nd*tau2) / tau # [g / L / h]
    P_pp = (P_pp_1st*tau1 + P_pp_2nd*tau2) / tau # [g / L / h]
    P_ComsuptionG = (P_ComsuptionG1*tau1 + P_ComsuptionG2*tau2) / tau # [g / L / h]
    P_cell_growth_rate = (P_cell_growth_rate1*tau1 + P_cell_growth_rate2*tau2) / tau # [g / L / h]
    Y_Heme = (P_Heme_1st*tau1 + P_Heme_2nd*tau2) / (P_ComsuptionG1*tau1 + P_ComsuptionG2*tau2)
    Y_pp = (P_pp_1st*tau1 + P_pp_2nd*tau2) / (P_ComsuptionG1*tau1 + P_ComsuptionG2*tau2)
    Y_b = (P_cell_growth_rate1*tau1 + P_cell_growth_rate2*tau2) / (P_ComsuptionG1*tau1 + P_ComsuptionG2*tau2)
    Y_r = 1 - Y_Heme - Y_pp - Y_b # respiration yield on glucose
    
    SF = 0.45 # Secretion fraction of HemeB

    """
    
    Reactions
    """
    fermentation_reaction = bst.PRxn([
        #           Reaction        Reactnat            Conversion           Check                  "
        bst.Rxn('1 Glucose + 1.05882 NH3 + 0.17647 FeSO4  -> 0.17647 Heme_b + 0.617647 O2 + 0.17647 (NH4)2SO4 + 4.05882 H2O',
                                    reactant = 'Glucose',X=Y_Heme*SF,check_atomic_balance=True),
        bst.Rxn('1 Glucose + 1.05882 NH3 + 0.17647 FeSO4  -> 0.17647 Heme_b_In + 0.617647 O2 + 0.17647 (NH4)2SO4 + 4.05882 H2O',
                                    reactant = 'Glucose', X= Y_Heme*(1-SF),check_atomic_balance=True),
        bst.Rxn('1 Glucose + 0.70588 NH3  -> 0.17647 ProtoporphyrinIX + 0.618 O2 + 4.06 H2O',
                                    reactant = 'Glucose', X=Y_pp*SF,correct_atomic_balance=True),
        bst.Rxn('1 Glucose + 0.70588 NH3 -> 0.17647 ProtoporphyrinIX_In + 0.618 O2 + 4.06 H2O',
                                    reactant = 'Glucose', X=Y_pp*(1-SF),correct_atomic_balance=True),
        ])
    fermentation_reaction[0].product_yield('Heme_b', basis='wt', product_yield=Y_Heme*SF)
    fermentation_reaction[1].product_yield('Heme_b_In', basis='wt', product_yield=Y_Heme*(1-SF))
    fermentation_reaction[2].product_yield('ProtoporphyrinIX', basis='wt', product_yield=Y_pp*SF)
    fermentation_reaction[3].product_yield('ProtoporphyrinIX_In', basis='wt', product_yield=Y_pp*(1-SF))
    
    neutralization_reaction = bst.Rxn(
        'H2SO4 + 2 NH3 -> (NH4)2SO4', reactant = 'H2SO4', X=1,
        check_atomic_balance=True
    )
    
    cell_growth_reactionCG = bst.Rxn(
        'Glucose + 1.32 NH3 + 1.32 H2O-> 6 Corynebacterium_glutamicum + 2.37 O2', 'Glucose', X=Y_b,
        correct_atomic_balance=True
    )
    cell_growth_reactionCG.product_yield('Corynebacterium_glutamicum', basis='wt', product_yield=Y_b)
    
    respiration_reactionGC1 = bst.Rxn(
        'Glucose + 6 O2 -> 6 CO2 + 6 H2O', 'Glucose', 1 - Y_b,
        check_atomic_balance=True
    )

    respiration_reactionGC2 = bst.Rxn(
        'Glucose + 6 O2 -> 6 CO2 + 6 H2O', 'Glucose', (1 - Y_b - Y_pp - Y_Heme)*0.95,
        check_atomic_balance=True
    )
    
    respiration_reactionGC3 = bst.Rxn(
        'Glucose -> 2 EtOH + 2 CO2', 'Glucose', (1 - Y_b - Y_pp - Y_Heme)*0.05,
        check_atomic_balance=True
    )
    
    RXN = bst.ReactionSystem(
        fermentation_reaction,
        bst.PRxn([cell_growth_reactionCG, respiration_reactionGC2, respiration_reactionGC3]),
    )
    RXN.show()
    
    
    """
    Upstream Process
    """
    M301 = bst.MixTank('M301', ins=[SeedIn1,'Water1'], outs='M301Out', tau=16)
    @M301.add_specification(run=True)
    def update_seed1_inputs():
        target_stream = bst.Stream(**s.SeedSolution1)
        SeedIn1.imass['Seed'] = target_stream.imass['Seed']
        M301.ins[1].imass['H2O'] = target_stream.imass['H2O']
        M301.ins[1].T = 25+273.15
    
    M302 = bst.MixTank('M302', ins=[SeedIn2,CultureIn,'Water2'], outs='M302Out', tau=16)
    @M302.add_specification(run=True)
    def update_culture_inputs():
        target_stream = bst.Stream(**s.SeedSolution2)
        SeedIn2.imass['Seed'] = target_stream.imass['Seed']
        M302.ins[2].imass['H2O'] = target_stream.imass['H2O']
        M302.ins[2].T = 25+273.15
        CultureIn.imass['Culture'] = target_stream.imass['SeedSolution']*(0.1+60+0.15191)/1000

    M303 = u.SeedHoldTank('M303', ins=[M301-0, M302-0], outs='M303Out')

    R301 = u.SeedTrain(
        'R301',
        ins=[M303-0],
        outs=[vent1, 'R301Out'],
        reactions=bst.PRxn([cell_growth_reactionCG, respiration_reactionGC2, respiration_reactionGC3]),
        saccharification=None,
        T=32+273.15,
    )
    R301.add_specification(run=True)
    
    M304 = bst.MixTank('M304', ins=[Glucose,'Water3'], outs='M304Out', tau=16)
    
    @M304.add_specification(run=True)
    def update_water_content():
        M304.ins[1].imass['H2O'] = Glucose.imass['Glucose']/2
        M304.ins[1].T = 25+273.15
    
    T301 = bst.StorageTank('T301', ins=M304-0, outs='T301Out',tau=16*4+72)

    T302 = u.AmmoniaStorageTank('T302', ins=NH3_25wt, outs='T302Out')

    # checking more details...
    R302 = u.AeratedFermentation(
        'R302',
        ins=[R301-1, T301-0, T302-0, bst.Stream('FilteredAir', phase='g', P=2 * 101325)],
        outs=[vent2, 'Broth'],
        fermentation_reaction=fermentation_reaction,
        cell_growth_reaction=cell_growth_reactionCG,
        respiration_reaction=respiration_reactionGC2,
        neutralization_reaction=neutralization_reaction,
        design='Stirred tank', method=method,theta_O2=theta_O2,
        V_max=V_max, Q_O2_consumption=Q_O2_consumption,
        dT_hx_loop=dT_hx_loop, T=T_operation,
        batch=True, reactions=RXN,
        kW_per_m3=agitation_power,
        tau=tau,
        cooler_pressure_drop=cooler_pressure_drop,
        compressor_isentropic_efficiency=compressor_isentropic_efficiency,
        P=1 * 101325,
    )
    R302.target_titer = tau*P_Heme # g / L
    R302.target_productivity = P_Heme # g / L / h
    R302.target_yield = Y_Heme  # wt %

    @R302.add_specification(run=True)
    def update_reaction_time_and_yield():
        R302.tau = R302.target_titer / R302.target_productivity
        fermentation_reaction[0].product_yield('Heme_b', basis='wt', product_yield=R302.target_yield*SF)
        fermentation_reaction[1].product_yield('Heme_b_In', basis='wt', product_yield=R302.target_yield*(1-SF))
        fermentation_reaction[2].product_yield('ProtoporphyrinIX', basis='wt', product_yield=Y_pp*SF)
        fermentation_reaction[3].product_yield('ProtoporphyrinIX_In', basis='wt', product_yield=Y_pp*(1-SF))

    """
    Downstream process
    """
    
    # Define order chemicals outside the unit for easy access in specification
    centrifuge_order = ('Corynebacterium_glutamicum', 'Heme_b_In', 'ProtoporphyrinIX_In')
    S401 = u.Centrifuge(
        'S401',
        ins=R302-1,
        outs=('Deposite', 'Supernatant'),
        moisture_content = 0.4,
        split = (0.999, 0.999, 0.999),
        order = centrifuge_order,
    )
    @S401.add_specification(run=True)
    def update_centrifuge_splits():
        inlet = S401.ins[0]
        
        # First run to get initial outlet composition
        S401._run()
        
        outlets_solid = S401.outs[0]
        
        # Calculate water residual ratio (fraction of water going to solids)
        if inlet.imass['H2O'] > 0:
            waterresidual = outlets_solid.imass['H2O'] / inlet.imass['H2O']
        else:
            waterresidual = 0.
        
        # Get all chemical IDs
        order_chemicals = set(centrifuge_order)
        
        # Update splits: target chemicals go to solids (0.999), others follow water
        for chem in S401.chemicals:
            chem_id = chem.ID
            if chem_id in order_chemicals:
                S401.isplit[chem_id] = 0.999  # These go to solids stream
            elif chem_id == 'H2O':
                pass  # Water is handled by moisture_content
            else:
                S401.isplit[chem_id] = waterresidual  # Follow water distribution
        
        # Re-run with updated splits
        S401._run()

    
    S402 = u.CellDisruption(
        'S402', ins=S401-0, outs='DisruptedDeposite', 
        Cell_ID ='Corynebacterium_glutamicum',
        component_fractions={
                            'Protein': 0.45,
                            'Cellulose': 0.22,
                            'Xylan': 0.15,
                            'OleicAcid': 0.08,
                            'RNA':0.10,
        }
    )

    S403 = bst.Centrifuge(
        'S403', ins=S402-0, outs=('Debris','IntraProduct'),
        moisture_content=0.20,
        split=(1, 1, 1, 1, 1, 1, 1),
        order=('Heme_b_In', 'ProtoporphyrinIX_In','Corynebacterium_glutamicum','Protein','Cellulose', 'Xylan','OleicAcid','RNA'),
    )
    
    M401 = bst.MixTank('M401', ins=('','Water5'), 
                    outs='RAEquilibrium', tau=1)
    M402 = bst.MixTank('M402', ins=('','Water6'),
                    outs='RAElution', tau=1)
    M403 = bst.MixTank('M403', ins=('','Water6'),
                    outs='RARegeneration', tau=1)
    
    H401 = bst.HXutility(
        'H401',
        ins=M401-0,
        outs='H401Out',
        T=30+273.15,  # Cool to 30°C
        heat_only=True,
    )
    H402 = bst.HXutility(
        'H402',
        ins=M402-0,
        outs='H402Out',
        T=40+273.15,  # Cool to 40°C
        heat_only=True,
    )
    H403 = bst.HXutility(
        'H403',
        ins=M403-0,
        outs='H403Out',
        T=30+273.15,  # Cool to 30°C
        heat_only=True,
    )
    
    U401 = u.ResinAdsorption(
        'U401',
        ins = (S401-1, H401-0, H402-0, H403-0),
        outs = ('ExtraProduct','FlowthroughWaste','WashWaste','RegenerationWaste'),
        TargetProduct_IDs = ('Heme_b','ProtoporphyrinIX'),
        TargetProduct_Yield=0.98,
        BoundImpurity_IDs=(c.chemical_groups['Salts'],'Glucose','Glycine','Ethanol'),
        BoundImpurity_Removal=0.999,
        NonBinding_Carryover=0.05,
        wash_CV=3,
        elution_CV=0.05,
        regeneration_CV=0.05,
    ) 
    
    @M401.add_specification(run=True)
    def update_RAEquilibrium_initial():
        M401.ins[1].imass['H2O'] = (S401-1).imass['H2O']*U401.wash_CV
        M401.ins[0].imass['NaCl'] = (S401-1).imass['H2O']*U401.wash_CV*0.002/0.998
    @M402.add_specification(run=True)
    def update_RAElution_initial():
        M402.ins[1].imass['H2O'] = (S401-1).imass['H2O']*U401.elution_CV
        M402.ins[0].imol['NaOH'] = (S401-1).imass['H2O']*U401.elution_CV*0.2/1000
    @M403.add_specification(run=True)
    def update_RARegeneration_initial():
        # M403.ins[1].imass['H2O'] = (S401-1).imass['H2O']*U401.regeneration_CV
        # M403.ins[0].imol['NaOH'] = (S401-1).imass['H2O']*U401.regeneration_CV*1/1000
        M403.ins[1].imass['H2O'] = (S401-1).imass['H2O']*U401.regeneration_CV*0.3
        M403.ins[0].imass['Ethanol'] = (S401-1).imass['H2O']*U401.regeneration_CV*0.7
    

if __name__ == '__main__':
    bst.preferences.N = 50
    Hm_sys = create_Heme_system()
    sys = Hm_sys
    f = sys.flowsheet
    u = f.unit
    ss = f.stream
    sys.operating_hours = 8000
    sys.simulate()
    sys.diagram(format='html',display=True)


================ FILE: LegH\__init__.py ================

# -*- coding: utf-8 -*-
"""
LegH Subpackage - Leghemoglobin Production

This subpackage contains all modules specific to the LegH (Leghemoglobin) production process.

Modules:
    - chemicals: Chemical species definitions for LegH process
    - system: Main flowsheet/system factory
    - streams: Input stream definitions
    - tea: Techno-economic analysis class
    - models: Uncertainty/sensitivity analysis models

@author: Dr. Ouwen Peng
@institute: Illinois ARCS
"""

from .chemicals import create_chemicals_LegH, chemical_groups
from .system import create_LegH_system, set_production_rate, check_LegH_specifications
from .streams import *
from .tea import PreFerSTEA

__all__ = (
    'create_chemicals_LegH',
    'chemical_groups',
    'create_LegH_system',
    'set_production_rate',
    'check_LegH_specifications',
    'PreFerSTEA',
)



================ FILE: LegH\chemicals.py ================

# -*- coding: utf-8 -*-
"""
LegH Chemicals Module

Extracted from the original _chemicals.py for the LegH (Leghemoglobin) process.

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

# %%
import biosteam as bst
from networkx import density
import thermosteam as tmo
import numpy as np
from thermosteam.utils import chemical_cache
from thermosteam import functional as fn
import pandas as pd
from fractions import Fraction

from traitlets import default

__all__ = (
    'get_grouped_chemicals',
    'create_chemicals_LegH',
    'chemical_groups',
)

# %% Constants

# Heats of formation for cellulosic components are from Humbird 2011 report: https://www.nrel.gov/docs/fy11osti/47764.pdf
# They are originally found in calories, so we need to convert them to joule.
_cal2joule = 4.184 # auom('cal').conversion_factor('J')
Cp_cellulosic = 1.364

#: Default liquid chemicals for saccharification solids-loading specification
default_nonsolids = ['Water', 'Ethanol', 'AceticAcid', 
                    'H2SO4', 'NH3']

chemical_groups = dict(
    LegHIngredients = ('Leghemoglobin',
                    'TrehaloseDH',
                    'SodiumAscorbate',
                    ),
    Addictive = ('Pichia_pastoris',
                'Glycine',
                'TrehaloseDH',
                'SodiumAscorbate',),

    # Negtive
    BoundImpurities = (
                    'EDTA',
                    'Glycine',
                    'RNA',
                    'Mannoprotein',
                    'OleicAcid'),

    ElutionBuffer = ('NaCl',
                    'KCl'),

    Salts = ('KOH',
            'NaCl',
            'KCl',
            '(NH4)2SO4',
            'FeSO4',
            'MgSO4',
            'KH2PO4',
            'K2HPO4',
            '(NH4)2HPO4',
            'K2HPO4',
            'NH3',
            'Na2SO4',
            'NaHSO4',
            'NaOH',
            'NaH2PO4',
            'Na2HPO4',
            'NH3',
            'HCl',
            'H2SO4',
            ),
    
    OtherLargeMolecules = (#'Cellmass',
                        'Yeast',
                        'Pichia_pastoris',
                        'Z_mobilis',
                        'T_reesei',
                        'Biomass',
                        'Cellulose',
                        'Glucan',
                        'Xylan',
                        'Xylitol',
                        'Cellobiose',
                        'CSL',
                        'Globin',
                        'Mannoprotein',
                        'Chitin',
                        'OleicAcid',
                        'RNA'),

    OtherSugars = ('Arabinose',
                    'Mannose',
                    'Galactose',
                    'Cellobiose',
                    'Sucrose'),
    OrganicSolubleSolids = ('AmmoniumAcetate',
                            'SolubleLignin',
                            'Extract', 
                            'LacticAcid', 
                            'Cellulase'),
    COxSOxNOxH2S = ('NO',
                    'NO2',
                    'SO2',
                    'CO',
                    'H2S'),  
    Protein = ('Protein',
                'Enzyme',
                'DenaturedEnzyme'),                     
)

def get_grouped_chemicals(stream, units='kmol/hr'):
    new_stream = tmo.Stream(stream.thermo)
    new_stream.set_flow(stream.mol, units, stream.chemicals.IDs)
    data = {group: new_stream.get_flow(units, IDs).sum() for group, IDs in chemical_groups.items()}
    return pd.Series(data)


# %%
#@chemical_cache
def create_chemicals_LegH():
    ##############################################
    ##### set function of create new chemical ####
    ##############################################    
    chems = bst.Chemicals([])

    def add_chemical(ID, source=None, Cp=None, **data):
        chemical = tmo.Chemical.blank(ID, **data)
        if source: 
            default_phase_ref = source.phase_ref
            chemical.copy_models_from(source)
        else:
            default_phase_ref = 'l'
        if not chemical.phase_ref:
            chemical.phase_ref = default_phase_ref
        chemical.at_state(chemical.phase_ref)
        if Cp is not None: set_Cp(chemical, Cp)
        chemical.default()
        chems.append(chemical)

    def append_chemical(ID, search_ID=None, **data):
        chemical = tmo.Chemical(ID, search_ID=search_ID, **data)
        try: chemical.at_state(phase=chemical.phase_ref)
        except: pass
        chemical.default()    
        chems.append(chemical)
    
    def extend_chemical(IDs, **data):
        for ID in IDs: append_chemical(ID, **data)
    
    def append_chemical_copy(ID, chemical):
        new_chemical = chemical.copy(ID)
        chems.append(new_chemical)
    
    def set_Cp(single_phase_chemical, Cp):
        chem = single_phase_chemical
        chem.Cn.add_model(Cp * chem.MW, top_priority=True)
    
    def set_rho(single_phase_chemical, rho):
        V = fn.rho_to_V(rho, single_phase_chemical.MW)
        single_phase_chemical.V.add_model(V, top_priority=True)   

    def add_chemical(ID, ref=None, **data):
        chemical = bst.Chemical(ID, **data) if ref is None else ref.copy(ID, **data)
        chems.append(chemical)
        return chemical
    
    #########################
    #### Define Species #####
    #########################

    #### General Liquid #####
    add_chemical('H2O')
    add_chemical('H2SO4', phase='l')

    #### Gases ####
    add_chemical('O2', phase='g', Hf=0)
    add_chemical('N2', phase='g', Hf=0)
    add_chemical('CH4', phase='g')
    add_chemical('CO', search_ID='CarbonMonoxide', phase='g', Hf=-26400*_cal2joule)
    add_chemical('CO2', phase='g')
    add_chemical('NH3', phase='g', Hf=-10963*_cal2joule)
    add_chemical('NO', search_ID='NitricOxide', phase='g',formula='NO', Hf=82.05)
    add_chemical('NO2', phase='g', formula='NO2', Hf=7925*_cal2joule)
    add_chemical('H2S', phase='g', Hf=-4927*_cal2joule)
    add_chemical('SO2', phase='g')

    ##### Soluble inorganics #####
    add_chemical('KOH', phase='l', default=True)
    add_chemical('NaOH', phase='l', default=True)
    add_chemical('NaCl', phase='l', default=True)
    add_chemical('KCl', phase='l', default=True)

    add_chemical('(NH4)2SO4', phase='l', default=True, Hf=-288994*_cal2joule,aliases=['AmmoniumSulfate'])
    add_chemical('FeSO4', phase='l', default=True)
    add_chemical('MgSO4', phase='l', default=True) # 0.0001 $/kg
    Na2SO4 = add_chemical('Na2SO4', phase='l', default=True)
    Na2SO4.V.add_model(fn.rho_to_V(rho=2664, MW=Na2SO4.MW), top_priority=True)  # Density of solid Na2SO4
    
    NaHSO4 = add_chemical('NaHSO4', phase='l', default=True)
    NaHSO4.V.add_model(fn.rho_to_V(rho=2435, MW=NaHSO4.MW), top_priority=True)  # Density of solid NaHSO4

    add_chemical('KH2PO4', phase='l', default=True)
    add_chemical('K2HPO4', phase='l', default=True)
    add_chemical('NaH2PO4', phase='l', default=True)
    add_chemical('Na2HPO4', phase='l', default=True)
    add_chemical('(NH4)2HPO4', phase='l', default=True)
    
    # trace_metal_solution
    add_chemical('HCl', phase='l', default=True)
    add_chemical('CaCl2', phase='s', default=True)
    add_chemical('ZnSO4', phase='s', default=True)
    add_chemical('MnSO4', phase='s', default=True)
    add_chemical('CoCl2', phase='s', default=True)
    add_chemical('CuSO4', phase='s', default=True)
    add_chemical('(NH4)6Mo7O24', search_ID='PubChem=61578', phase='s', default=True)
    add_chemical('Na2B4O7', phase='s', default=True)

    #### Main Organic ####
    add_chemical('Glycine', phase='s')
    add_chemical('CitricAcid', phase='l', default=True)
    add_chemical('AceticAcid', phase='l', default=True)
    add_chemical('LacticAcid', phase='l', default=True)
    add_chemical('Glucose', phase='s', default=True)
    add_chemical('Dextrose', phase='l', default=True)
    add_chemical('IPTG', phase='l', default=True)
    #add_chemical('Tryptone', phase='l', default=True)
    add_chemical('Ethanol', phase='l', default=True)
    add_chemical('Glycerol', phase='s', default=True)
    add_chemical('SuccinicAcid', phase='s', default=True)
    add_chemical('EDTA', phase='s', default=True)
    add_chemical('Trehalose', search_ID='PubChem=7427', phase='s', default=True)
    add_chemical('TrehaloseDH', search_ID='6138-23-4', phase='s', default=True)
    add_chemical('SodiumAscorbate', search_ID='134-03-2', phase='s', default=True)

    # antibiotics   
    add_chemical('Ampicillin', phase='l', default=True)
    add_chemical('Kanamycin', phase='l', default=True)
    add_chemical('Streptomycin', phase='l', default=True)
    add_chemical('Chloramphenicol', phase='l', default=True)
    
    CaSO4 = add_chemical('CaSO4', phase='s', default=True)
    CaO = add_chemical('CaO', phase='s', default=True)
    soluble_solids = [CaO]
    Ash=add_chemical('Ash',MW=1.,search_db=False) # Dummy chemical for ash
    P4010 = add_chemical('P4O10',phase = 'l',Hf=-582000*_cal2joule) # For phosphate precipitation
    insoluble_solids = [Ash, P4010]

    for chemical in insoluble_solids:
        V = fn.rho_to_V(rho=1540, MW=chemical.MW)
        try: chemical.V.s.add_model(V, top_priority=True)
        except: pass
    for chemical in soluble_solids:
        V = fn.rho_to_V(rho=1e5, MW=chemical.MW)
        try: chemical.V.add_model(V, top_priority=True)
        except: pass

    Ash.Cn.s.add_method(0.09 * 4.184 * Ash.MW) # Heat capacity model
    
    # Add missing thermodynamic properties for ash
    Ash.Psat.add_method(1e-10)
    Ash.Tb = 3000  # High boiling point for solid
    Ash.Hvap.add_method(0)

    Ash.get_missing_properties()

    #############
    #### Bio ####
    #############

    Yeast = add_chemical(
        'Yeast',
        phase='s',
        formula='CH1.61O0.56',#N0.16', #if yeast_includes_nitrogen else 'CH1.61O0.56',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        #aliases=['Cellmass'],
    )
    Yeast.Hf = chems.Glucose.Hf / chems.Glucose.MW * Yeast.MW 
    # Same as glucose to ignore heats related to growth 

    # https://microbialcellfactories.biomedcentral.com/articles/10.1186/1475-2859-11-57/tables/2?utm_source=chatgpt.com
    # Lange HC, Heijnen JJ: Statistical reconciliation of the elemental 
    # and molecular biomass composition of Saccharomyces cerevisiae. 
    # Biotechnol Bioeng. 2001, 75: 334-344. 10.1002/bit.10054.

    # Szyperski T: Biosynthetically directed fractional 13C-labeling of proteinogenic amino acids.
    # An efficient analytical tool to investigate intermediary metabolism. 
    # Eur J Biochem. 1995, 232: 433-448. 10.1111/j.1432-1033.1995.tb20829.x.
    Pichia_pastoris = add_chemical(
        'Pichia_pastoris',
        phase='s',
        formula='CH1.761N0.143O0.636S0.0018',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    Pichia_pastoris.Hf = chems.Glucose.Hf / chems.Glucose.MW * Pichia_pastoris.MW 
    # Same as glucose to ignore heats related to growth 

    K_marxianus = add_chemical(
        'K_marxianus',
        phase='s',
        formula = 'CH1.78O0.66N0.158P0.009S0.0035',#K0.0015',
        rho=1540,
        Cp=chems.Glucose.Cp(298.15), # 1.54
        default=True,
        search_db=False,
        # aliases=['Cellmass'],
    )
    K_marxianus.Hf = chems.Glucose.Hf / chems.Glucose.MW * K_marxianus.MW
    # Same as glucose to ignore heats related to growth

    add_chemical('Glucan', phase='s')
    add_chemical('Mannoprotein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Chitin', search_ID='N-acetylglucosamine', phase='s')
    add_chemical('OleicAcid', phase='l', default=True)
    add_chemical('RNA', search_ID='Uracil', phase='s')

    add_chemical('Z_mobilis', formula="CH1.8O0.5N0.2",
                                    default=True, search_db=False,
                                    Hf=-31169.39*_cal2joule, phase='s')
    add_chemical('T_reesei', formula="CH1.645O0.445N0.205S0.005",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Biomass', formula="CH1.64O0.39N0.23S0.0035",
                default=True, search_db=False,
                Hf=-23200.01*_cal2joule, phase='s')
    add_chemical('Cellulose', formula="C6H10O5", # Glucose monomer minus water
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-233200.06*_cal2joule,
                phase='s')
    add_chemical('Protein', formula="CH1.57O0.31N0.29S0.007",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Lignin', formula="C9H10O2", # A monomeric unit
                default=True, search_db=False,
                Hf=-182100*_cal2joule, phase='s')
    add_chemical('Enzyme', formula="CH1.59O0.42N0.24S0.01",
                default=True, search_db=False,
                Hf=-17618*_cal2joule, phase='s')
    add_chemical('Xylan', formula="C5H8O4",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-182100*_cal2joule,
                phase='s')
    add_chemical('Xylitol', formula="C5H12O5",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-243145*_cal2joule, phase='s')
    add_chemical('Cellobiose', formula="C12H22O11",
                Cp=Cp_cellulosic,
                default=True, search_db=False,
                Hf=-480900*_cal2joule, phase='s')
    add_chemical('CSL', 
                formula='H2.8925O1.3275C1N0.0725S0.00175',
                default=True, search_db=False,
                Hf=(chems.Protein.Hf/4
                    + chems.H2O.Hf/2
                    + chems.LacticAcid.Hf/4), phase='s')
    append_chemical_copy('DenaturedEnzyme', chems.Enzyme)
    append_chemical_copy('WWTsludge', chems.Biomass)
    append_chemical_copy('Cellulase', chems.Enzyme)

    # heme molecule formula: C34H32FeN4O4
    # heme_b = add_chemical('heme')
    Heme_b = add_chemical('Heme_b', search_ID='PubChem=26945', phase='s', default=True)
    add_chemical('VitaminC', search_ID='AscorbicAcid', phase='s', default=True)

    # Only protein: 144 amino acids Formula:C729H1166N200O219S2​
    # https://www.uniprot.org/uniprotkb/P02236/entry#sequences
    protein_formula = {
        'H': 1166 / 729,
        'C': 729 / 729,
        'N': 200 / 729,
        'O': 219 / 729,
        'S': 2 / 729
    }
    formula = {i: round(j, 6) for i, j in protein_formula.items()}
    Globin = add_chemical(
        'Globin',
        search_db=False,
        default=True,
        atoms=formula,
        phase='s'
    )
    Leghemoglobin_formula = {
        'H': (1166+32) / (729+34),
        'C': (729+34) / (729+34),
        'N': (200 +4) / (729+34),
        'O': (219+4) / (729+34),
        'S': 2 / (729+34),
        'Fe': 1 / (729+34)
    }
    formula2 = {i: round(j, 6) for i, j in Leghemoglobin_formula.items()}
    Leghemoglobin = add_chemical(
        'Leghemoglobin',
        search_db=False,
        default=True,
        atoms=formula2,
        phase='s',
        aliases=['LegH']
    )
    append_chemical_copy('Leghemoglobin_In', Leghemoglobin)
    append_chemical_copy('Globin_In', Globin)

    # Default missing properties of chemicals to those of water
    for chemical in chems: chemical.default()

    #################
    ##### Group #####
    #################
    chems.compile()
    chems.set_synonym('H2SO4', 'SulfuricAcid')
    chems.set_synonym('NH3', 'Ammonia')
    chems.set_synonym('H2O', 'Water')
    chems.set_synonym('Pichia_pastoris','cellmass')
    chems.set_synonym('(NH4)2HPO4','DAP')
    chems.set_synonym('Leghemoglobin','LegH')
    chems.set_synonym('Ethanol','EtOH')
    TMS = np.array([5*0.33, 2, 2.2, 1.5, 0.25, 0.5, 0.23, 0.47])*np.array([0.37,1,0.5614,0.6264,0.54557,0.6392,0.9417,0.5276])
    TMS_list = TMS.tolist()
    chems.define_group(
        'TraceMetalSolution',
        ['HCl','CaCl2','ZnSO4','MnSO4','CoCl2','CuSO4','(NH4)6Mo7O24','Na2B4O7','H2O'],
        TMS_list + [(1000 - sum(TMS_list))],
        wt=True
    )
    # 50mg/L Vitamin C Solution
    chems.define_group(
        'VitaminCSolution',
        ['VitaminC','H2O'],
        [0.05, (1000 - 0.05)],
        wt=True
    )
    
    chems.define_group(
        'air',
        ['O2', 'N2'],
        [28, 72],
        wt=True
    )

    # 16hour 150ml
    chems.define_group(
        'SeedSolution',
        ['H2O','(NH4)2SO4','Glucose','MgSO4','KH2PO4'],
        [100, 0.5, 1, 0.05, 0.3],
        wt=True
    )
    
    chems.define_group(
        'Seed',
        ['(NH4)2SO4','Glucose','MgSO4','KH2PO4'],
        [0.5, 1, 0.05, 0.3],
        wt=True
    )

    # 1.5 L
    chems.define_group(
        'CultureSolution',
        ['SeedSolution','Glycine','Glucose','FeSO4'],
        [1000, 0.1, 60, 0.15191],
        wt=True
    )

    chems.define_group(
        'Culture',
        ['Glycine','Glucose','FeSO4'],
        [0.1, 60, 0.15191],
        wt=True
    )

    # 25wt%NH3
    chems.define_group(
        'NH3_25wt',
        ['NH3','H2O'],
        [25,75],
        wt=True
    )

    chems.define_group(
        'DfUltraBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )

    chems.define_group(
        'IXEquilibriumBuffer',
        ['KH2PO4','NaCl','EDTA'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.001*bst.Chemical('EDTA', phase='l', default=True).MW],
        wt=True,
    )
    chems.define_group(
        'IXElutionBuffer',
        ['KH2PO4','NaCl','KCl'],
        [0.025*bst.Chemical('KH2PO4', phase='l', default=True).MW, 
        1.0*bst.Chemical('NaCl', phase='l', default=True).MW,
        0.01*bst.Chemical('KCl', phase='l', default=True).MW],
        wt=True,
    )

    chems.define_group(
        'DfNanoBuffer',
        ['Na2HPO4','NaH2PO4'],
        [0.01*bst.Chemical('Na2HPO4', phase='l', default=True).MW, 
        0.01*bst.Chemical('NaH2PO4', phase='l', default=True).MW],
        wt=True,
    )

    if bst.settings.set_thermo: bst.settings.set_thermo(chems)
    return chems



================ FILE: LegH\models.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-01-XX

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

import biosteam as bst
from chaospy import distributions as shape
from biorefineries.prefers.LegH.system import create_LegH_system, set_production_rate
from biorefineries.prefers.LegH.tea import PreFerSTEA
from biorefineries.prefers.process_settings import load_process_settings

__all__ = ('create_model',)

def create_model(baseline_production_kg_hr=275):
    """
    Create a Model object for uncertainty and sensitivity analysis of the LegH production facility.
    
    Parameters
    ----------
    baseline_production_kg_hr : float, optional
        Baseline target production rate [kg/hr]. Default is 275 kg/hr.
    
    Returns
    -------
    model : biosteam.Model
        Configured model with parameters and metrics for analysis.
    """
    # Load process settings and create system
    load_process_settings()
    LegH_sys = create_LegH_system()
    
    # Set baseline production rate using design specification
    print(f"Setting baseline production rate to {baseline_production_kg_hr} kg/hr...")
    set_production_rate(LegH_sys, baseline_production_kg_hr)
    
    # Create TEA object
    LegH_tea = PreFerSTEA(
        system=LegH_sys, 
        IRR=0.18, 
        duration=(2024, 2044), 
        depreciation='IRAS6',
        income_tax=0.17, 
        operating_days=333, 
        lang_factor=None,
        construction_schedule=(0.15, 0.60, 0.25), 
        WC_over_FCI=0.15,
        labor_cost=10*6e4, 
        fringe_benefits=0.17+0.07, 
        property_tax=0.005,
        property_insurance=0.005, 
        supplies=0.02, 
        maintenance=0.03,
        administration=0.05
    )
    
    # Get references to key units and streams
    f = LegH_sys.flowsheet
    R302 = f.unit.R302  # Fermentation unit
    glucose = f.stream.Glucose  # Glucose feedstock stream
    LegH_product = f.stream.LegH_3  # Main product stream
    
    # Create model
    model = bst.Model(LegH_sys)
    param = model.parameter
    metric = model.metric
    
    # =============================================================================
    # PARAMETER 1: Target Production Rate (Production Scale)
    # =============================================================================
    baseline_production = baseline_production_kg_hr
    lb_production = baseline_production * 0.5  # -50% (137.5 kg/hr)
    ub_production = baseline_production * 2.0  # +100% (550 kg/hr)
    
    @param(
        name='Production scale', 
        element='Design', 
        kind='coupled',
        units='kg/hr',
        baseline=baseline_production,
        bounds=(lb_production, ub_production),
        distribution=shape.Uniform(lower=lb_production, upper=ub_production)
    )
    def set_target_production(production_rate_kg_hr):
        """Set target production rate and resize entire plant using design specification."""
        achieved_rate = set_production_rate(LegH_sys, production_rate_kg_hr)
        
        if abs(achieved_rate - production_rate_kg_hr) > 1.0:
            print(f"Warning: Target production {production_rate_kg_hr:.2f} kg/hr, "
                  f"achieved {achieved_rate:.2f} kg/hr")
    
    # =============================================================================
    # PARAMETER 2: Fermentation Titer
    # =============================================================================
    baseline_titer = R302.target_titer  # Current titer (7.27 g/L)
    lb_titer = baseline_titer * 0.8  # -20% (5.8 g/L)
    ub_titer = baseline_titer * 1.2  # +20% (8.7 g/L)
    
    @param(
        name='Fermentation titer', 
        element=R302, 
        kind='coupled',
        units='g/L',
        baseline=baseline_titer,
        bounds=(lb_titer, ub_titer),
        distribution=shape.Triangle(lower=lb_titer, midpoint=baseline_titer, upper=ub_titer)
    )
    def set_titer(titer):
        """Set fermentation titer (affects reactor volume and fermentation time)."""
        R302.target_titer = titer
    
    # =============================================================================
    # PARAMETER 3: Fermentation Productivity (NEW)
    # =============================================================================
    baseline_productivity = R302.target_productivity  # g/L/hr (~0.101 g/L/hr)
    lb_productivity = baseline_productivity * 0.5  # -50%
    ub_productivity = baseline_productivity * 1.5  # +50%
    
    @param(
        name='Fermentation productivity', 
        element=R302, 
        kind='coupled',
        units='g/L/hr',
        baseline=baseline_productivity,
        bounds=(lb_productivity, ub_productivity),
        distribution=shape.Triangle(lower=lb_productivity, midpoint=baseline_productivity, upper=ub_productivity)
    )
    def set_productivity(productivity):
        """Set fermentation productivity (affects fermentation time)."""
        R302.target_productivity = productivity
    
    # =============================================================================
    # PARAMETER 4: Substrate Yield (NEW)
    # =============================================================================
    baseline_yield = R302.target_yield  # Current yield
    lb_yield = baseline_yield * 0.75  # -25%
    ub_yield = baseline_yield * 1.5   # +50%
    
    @param(
        name='Substrate yield', 
        element=R302, 
        kind='coupled',
        units='%',
        baseline=baseline_yield * 100,
        bounds=(lb_yield * 100, ub_yield * 100),
        distribution=shape.Triangle(lower=lb_yield * 100, midpoint=baseline_yield * 100, upper=ub_yield * 100)
    )
    def set_yield(yield_percent):
        """Set product yield from substrate."""
        R302.target_yield = yield_percent / 100
    
    # =============================================================================
    # PARAMETER 5: Glucose Price
    # =============================================================================
    baseline_glucose_price = glucose.price  # Current glucose price (0.42 $/kg)
    lb_glucose = baseline_glucose_price * 0.7  # -30%
    ub_glucose = baseline_glucose_price * 1.3  # +30%
    
    @param(
        name='Glucose price', 
        element=glucose, 
        kind='isolated',
        units='$/kg',
        baseline=baseline_glucose_price,
        bounds=(lb_glucose, ub_glucose),
        distribution=shape.Triangle(lower=lb_glucose, midpoint=baseline_glucose_price, upper=ub_glucose)
    )
    def set_glucose_price(price):
        """Set glucose feedstock price."""
        glucose.price = price
    
    # =============================================================================
    # PARAMETER 6: Electricity Price
    # =============================================================================
    baseline_electricity_price = bst.PowerUtility.price  # Current price (0.03 $/kWh)
    lb_electricity = baseline_electricity_price * 0.7  # -30%
    ub_electricity = baseline_electricity_price * 1.3  # +30%
    
    @param(
        name='Electricity price', 
        element='TEA', 
        kind='isolated',
        units='$/kWh',
        baseline=baseline_electricity_price,
        bounds=(lb_electricity, ub_electricity),
        distribution=shape.Triangle(lower=lb_electricity, midpoint=baseline_electricity_price, upper=ub_electricity)
    )
    def set_electricity_price(price):
        """Set electricity utility price."""
        bst.PowerUtility.price = price
    
    # =============================================================================
    # METRICS
    # =============================================================================
    
    @metric(name='MSP', units='$/kg', element='PreFerS')
    def get_MSP():
        """Calculate minimum selling price of LegH product."""
        return LegH_tea.solve_price(LegH_product)
    
    @metric(name='TCI', units='10^6 $', element='PreFerS')
    def get_TCI():
        """Calculate total capital investment."""
        return LegH_tea.TCI / 1e6
    
    @metric(name='AOC', units='10^6 $/yr', element='PreFerS')
    def get_AOC():
        """Calculate annual operating cost."""
        return LegH_tea.AOC / 1e6
    
    @metric(name='GWP', units='kg CO2-eq/kg', element='PreFerS')
    def get_GWP():
        """
        Calculate global warming potential using BioSTEAM's LCA displacement allocation method.
        
        This method:
        1. Generates the LCA displacement allocation table
        2. Extracts the total GWP value (sum of inputs - outputs + process impacts)
        3. Returns GWP per kg of product
        
        Returns
        -------
        float
            GWP in kg CO2-eq per kg of LegH product
        """
        try:
            # Generate LCA displacement allocation table
            # This table calculates impacts based on:
            # - Material inputs (feeds)
            # - Energy consumption (heating, cooling, electricity)
            # - Process impacts (if any)
            # - Byproduct credits (displacement)
            lca_table = bst.report.lca_displacement_allocation_table(
                systems=[LegH_sys],
                key='GWP',
                items=[LegH_product],
            )
            
            # The table structure has:
            # - Index: Multi-level with categories (Inputs, Outputs, Process impacts, Total)
            # - Columns: ['Characterization factor [kg CO2-eq/kg]', 'System GWP [kg CO2-eq/kg*product]']
            
            # Extract total GWP from the 'Total' row
            # The last column contains GWP per kg product
            total_gwp = lca_table.loc[('Total', ''), lca_table.columns[-1]]
            
            return total_gwp
            
        except Exception as e:
            print(f"Warning: GWP calculation failed: {e}")
            return float('nan')
    
    @metric(name='Leghemoglobin content', units='%', element='PreFerS')
    def get_LegH_content():
        """Calculate leghemoglobin mass percent in final product."""
        if LegH_product.F_mass > 0:
            return LegH_product.imass['Leghemoglobin'] / LegH_product.F_mass * 100
        else:
            return float('nan')
    
    @metric(name='Protein purity', units='%', element='PreFerS')
    def get_protein_purity():
        """Calculate leghemoglobin purity relative to total protein."""
        # Define protein group
        protein_IDs = ['Leghemoglobin', 'Globin', 'Mannoprotein']
        total_protein = sum(LegH_product.imass[pid] for pid in protein_IDs if pid in LegH_product.chemicals.IDs)
        
        if total_protein > 0:
            return LegH_product.imass['Leghemoglobin'] / total_protein * 100
        else:
            return float('nan')
    
    @metric(name='Actual production', units='kg/hr', element='PreFerS')
    def get_actual_production():
        """Verify actual achieved production rate."""
        return LegH_product.F_mass
    
    @metric(name='Annual production', units='MT/yr', element='PreFerS')
    def get_annual_production():
        """Calculate annual production in metric tons per year."""
        return LegH_product.F_mass * LegH_sys.operating_hours / 1000
    
    @metric(name='Specific CAPEX', units='$/kg/yr', element='PreFerS')
    def get_specific_capex():
        """Calculate capital investment per unit annual capacity."""
        annual_capacity = LegH_product.F_mass * LegH_sys.operating_hours  # kg/yr
        if annual_capacity > 0:
            return LegH_tea.TCI / annual_capacity
        else:
            return float('nan')
    
    return model


# =============================================================================
# Verification function
# =============================================================================

def verify_model_integration():
    """Verification function to test that design mode integration works correctly."""
    print("="*80)
    print("PREFERS MODEL INTEGRATION VERIFICATION - EXPANDED PARAMETERS + LCA")
    print("="*80)
    
    # Create model
    print("\n1. Creating model...")
    model = create_model(baseline_production_kg_hr=275)
    
    # Display model structure
    print("\n2. Model structure:")
    model.show()
    
    # Test baseline
    print("\n3. Evaluating baseline...")
    baseline = model.metrics_at_baseline()
    print("\nBaseline Metrics:")
    for name, value in baseline.items():
        if 'GWP' in str(name):
            print(f"  {name}: {value:.6f} kg CO2-eq/kg")
        else:
            print(f"  {name}: {value:.4f}")
    
    # Test parameter changes
    print("\n4. Testing new parameters...")
    
    # Test productivity change
    print("\n   Testing productivity parameter...")
    model.set_parameters(fermentation_productivity=0.15)  # 50% increase
    model.evaluate()
    
    # Test yield change
    print("\n   Testing substrate yield parameter...")
    model.set_parameters(substrate_yield=75)  # 75% yield
    model.evaluate()
    
    print("\n5. All parameters tested successfully!")
    
    # Test LCA calculation specifically
    print("\n6. Testing LCA GWP calculation...")
    try:
        # Get system and product
        sys = model.system
        LegH_product = sys.flowsheet.stream.LegH_3
        
        # Generate LCA tables
        print("\n   Generating LCA inventory table...")
        lca_inventory = bst.report.lca_inventory_table(
            systems=[sys],
            key='GWP',
            items=[LegH_product],
        )
        print(f"   LCA inventory table shape: {lca_inventory.shape}")
        
        print("\n   Generating LCA displacement allocation table...")
        lca_displacement = bst.report.lca_displacement_allocation_table(
            systems=[sys],
            key='GWP',
            items=[LegH_product],
        )
        print(f"   LCA displacement table shape: {lca_displacement.shape}")
        
        # Extract GWP from table
        total_gwp = lca_displacement.loc[('Total', ''), lca_displacement.columns[-1]]
        print(f"\n   Total GWP from table: {total_gwp:.6f} kg CO2-eq/kg")
        
        # Compare with metric function
        metric_gwp = baseline[('PreFerS', 'GWP [kg CO2-eq/kg]')]
        print(f"   GWP from metric:      {metric_gwp:.6f} kg CO2-eq/kg")
        
        if abs(total_gwp - metric_gwp) < 1e-6:
            print("\n   ✓ GWP calculation verified!")
        else:
            print(f"\n   ⚠️  GWP mismatch: table={total_gwp:.6f}, metric={metric_gwp:.6f}")
        
    except Exception as e:
        print(f"\n   ✗ LCA verification failed: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n" + "="*80)
    print("VERIFICATION COMPLETE")
    print("="*80)


if __name__ == '__main__':
    verify_model_integration()


================ FILE: LegH\streams.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-05-07 18:26:22

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

from biosteam import stream_kwargs
from biorefineries.prefers._process_settings import price  # ADD THIS IMPORT
import biosteam as bst
from httpx import stream
import numpy as np  # ADD THIS IMPORT
LegH={}

titer = 7.27 # [g / L]
productivity = titer / 72 # [g / L / h]
LegH_yield = titer * 5 / 1300 # [by wt]

m=2/5 # scale up factor based on 1.5e5 kg/yr
# %% In
TraceMetalSolution = stream_kwargs('TraceMetalSolution', TraceMetalSolution=1, units='kg/hr', T=25+273.15)
VitaminCSolution = stream_kwargs('VitaminCSolution', VitaminC=1, units='kg/hr', T=25+273.15)
SeedIn1 = stream_kwargs('SeedIn1', Seed=1, units='kg/hr', T=25+273.15)
SeedIn2 = stream_kwargs('SeedIn2', Seed=1, units='kg/hr', T=25+273.15)
CultureIn = stream_kwargs('CultureIn', Culture=1, units='kg/hr', T=25+273.15)
SeedSolution1 = stream_kwargs('SeedSolution1', SeedSolution=m*0.15*1e5/16, units='kg/hr', T=25+273.15)
SeedSolution2 = stream_kwargs('SeedSolution2', SeedSolution=m*1.5*1e5/16, units='kg/hr', T=25+273.15)
CultureSolution = stream_kwargs('CultureSolution', CultureSolution=m*1.5*1e5/16, units='kg/hr', T=25+273.15)

Glucose = stream_kwargs('Glucose', Glucose=m*1.3*1e5/72, units='kg/hr', T=25+273.15)
NH3_25wt = stream_kwargs('NH3_25wt', NH3_25wt=m*300, units='kg/hr', T=25+273.15)#, price=price['NH3_25wt'])

DfUltraBuffer = stream_kwargs('DfUltraBuffer', DfUltraBuffer=1, units='kg/hr', T=25+273.15)
IXEquilibriumBuffer = stream_kwargs('IXEquilibriumBuffer', IXEquilibriumBuffer=1, units='kg/hr', T=25+273.15)
IXElutionBuffer = stream_kwargs('IXElutionBuffer', IXElutionBuffer=1, units='kg/hr', T=25+273.15)
IXRegenerationSolution = stream_kwargs('IXRegenerationSolution', NaOH =1, units='kg/hr', T=25+273.15)
DfNanoBuffer = stream_kwargs('DfNanoBuffer', DfNanoBuffer=1, units='kg/hr', T=25+273.15)

# %% Out

LegH_1 = stream_kwargs('LegH_1')
LegH_2 = stream_kwargs('LegH_2')
LegH_3 = stream_kwargs('LegH_3',units='kg/hr', T=25+273.15, price = 20)#11.006028727167918)
vent1 = stream_kwargs('vent1')
vent2 = stream_kwargs('vent2')
effluent1 = stream_kwargs('effluent1')
effluent2 = stream_kwargs('effluent2', units='kg/hr', price=-0.33)  # organic waste remove
effluent3 = stream_kwargs('effluent3')


# %%
# Add missing pricing functions directly here since they're not in your _streams2.py
def set_stream_price_from_components(stream, chemical_prices=None):
    """Set stream price based on individual chemical component prices"""
    from biorefineries.prefers._process_settings import price
    if chemical_prices is None:
        chemical_prices = price
    
    try:
        # FIX: Check if stream is a proper Stream object
        if not hasattr(stream, 'imass'):
            print(f"Warning: {stream} is not a proper Stream object, skipping pricing")
            return 0
            
        mass = stream.imass
        total_cost = 0
        total_mass = stream.F_mass
        
        # Handle individual chemicals in groups
        for chemical_id in stream.chemicals.IDs:
            if mass[chemical_id] > 0:
                # Check if this is a grouped chemical with group composition
                chemical = stream.chemicals[chemical_id]
                if hasattr(chemical, '_group_wt_composition') and chemical._group_wt_composition:
                    # This is a group - calculate based on group composition
                    group_mass = mass[chemical_id]
                    for component_id, fraction in chemical._group_wt_composition.items():
                        if component_id in chemical_prices:
                            component_cost = group_mass * fraction * chemical_prices[component_id]
                            total_cost += component_cost
                else:
                    # Individual chemical
                    if chemical_id in chemical_prices:
                        total_cost += mass[chemical_id] * chemical_prices[chemical_id]
        
        stream.price = total_cost / total_mass if total_mass > 0 else 0
        return stream.price
        
    except Exception as e:
        print(f"Warning: Could not set price for {getattr(stream, 'ID', 'unknown')}: {e}")
        if hasattr(stream, 'price'):
            stream.price = 0
        return 0

def create_stream(stream_list):
    """Create a new stream with default properties"""
    streams = []
    for stream_kwargs in stream_list:
        s = bst.Stream(**stream_kwargs)
        streams.append(s)
    return streams

def update_all_input_stream_prices(streamlist):
    """Update prices for all input streams"""
    # FIX: Check if streams exist and are proper objects
    try:
        input_streams = streamlist
        # input_streams = create_stream([SeedIn, CultureIn, Glucose, NH3_25wt, 
        #                 BufferA, BufferB, BufferC])
        
        for stream in input_streams:
            # FIX: Verify each stream is a proper Stream object
            if hasattr(stream, 'imass') and hasattr(stream, 'ID'):
                old_price = getattr(stream, 'price', 0)
                new_price = set_stream_price_from_components(stream)
                print(f"{stream.ID}: ${old_price:.4f}/kg → ${new_price:.4f}/kg")
            else:
                print(f"Warning: Stream {stream} is not properly initialized")
    except Exception as e:
        print(f"Error updating stream prices: {e}")


================ FILE: LegH\system.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-06-04 14:26:14

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

#from biorefineries.animal_bedding import _system
from ast import Yield
from biorefineries.prefers.process_settings import set_GWPCF, GWP_CFs, set_GWPCF_Multi, load_process_settings
from biorefineries.prefers.LegH import streams as s
import biosteam as bst
from pint import set_application_registry
from thermosteam import Stream
from biosteam import F
import thermosteam as tmo
import numpy as np
from biorefineries.prefers.LegH import chemicals as c
from biorefineries.prefers import units as u
from biorefineries.prefers.process_settings import price

# %% Settings
bst.settings.set_thermo(c.create_chemicals_LegH(), skip_checks=True)
bst.preferences.classic_mode()

# %%
__all__ = (
    'create_LegH_system',
)
# %%
@bst.SystemFactory(
    ID='LegH_sys',
    ins=[s.SeedIn1, s.SeedIn2, s.CultureIn, s.Glucose, s.NH3_25wt,s.DfUltraBuffer, s.IXEquilibriumBuffer, s.IXElutionBuffer
         ,s.IXRegenerationSolution, s.DfNanoBuffer],
    outs=[s.LegH_3, s.vent1, s.vent2, s.effluent1, s.effluent2, s.effluent3,
    ],
    fthermo=c.create_chemicals_LegH, # Pass the function itself
)
def create_LegH_system(
        ins, outs,
        use_area_convention=False,
        # reactions_passed=None, # Placeholder if reactions were to be passed externally
        # One could add more configurable parameters here:
        # V_max_fermenter=500, target_titer=7.27, etc.
    ):
    """
    Creates the LegH (Leghemoglobin) production system.
    This system is based on the process flow and parameters from test_LegH.py.
    """
    bst.preferences.N=50
    # Update all input stream prices before system creation to avoid conflicts
    # This is now done at the module level in _streams.py to prevent ID conflicts
    
    # Uncomment the line below if you need to update prices dynamically:
    #s.update_all_input_stream_prices()
    # Unpack input streams
    SeedIn1, SeedIn2, CultureIn, Glucose, NH3_25wt, DfUltraBuffer, IXEquilibriumBuffer, IXElutionBuffer, IXRegenerationSolution, DfNanoBuffer = ins

    # Unpack output streams
    (LegH_3, vent1, vent2, effluent1, effluent2, effluent3) = outs
    
    set_GWPCF(Glucose, 'Glucose')
    set_GWPCF_Multi(SeedIn1, ['AmmoniumSulfate','Glucose','MagnesiumSulfate','KH2PO4'],[0.5/(0.5+1+0.05+0.3), 1/(0.5+1+0.05+0.3), 0.05/(0.5+1+0.05+0.3), 0.3/(0.5+1+0.05+0.3)])
    set_GWPCF_Multi(SeedIn2, ['AmmoniumSulfate','Glucose','MagnesiumSulfate','KH2PO4'],[0.5/(0.5+1+0.05+0.3), 1/(0.5+1+0.05+0.3), 0.05/(0.5+1+0.05+0.3), 0.3/(0.5+1+0.05+0.3)])
    set_GWPCF_Multi(CultureIn, ['Glycine','Glucose','IronSulfate'],[0.1/(0.1+60+0.15191), 60/(0.1+60+0.15191), 0.15191/(0.1+60+0.15191)])
    set_GWPCF(NH3_25wt, 'Ammonia_SEA',dilution=0.25)
    set_GWPCF_Multi(DfUltraBuffer, ['KH2PO4','NaCl'], [0.8472, 0.1455])
    set_GWPCF_Multi(IXEquilibriumBuffer, ['KH2PO4','NaCl'], [0.8472, 0.1455])
    set_GWPCF_Multi(IXElutionBuffer, ['KH2PO4','NaCl','KCl'], [0.3616,0.5911, 0.0792])
    set_GWPCF(IXRegenerationSolution, 'NaOH')
    set_GWPCF_Multi(DfNanoBuffer, ['Na2HPO4','NaH2PO4'], [0.5420, 0.4580])

    load_process_settings()  # Load process settings to update prices and CFs
    """
    Fermentation Parameter
    """
    theta_O2 = 0.5 # Dissolved oxygen concentration [% saturation]
    agitation_power = 0.985 # [kW / m3]
    design = 'Stirred tank' # Reactor type
    method = "Riet" # Name of method
    T_operation = 273.15 + 32 # [K]
    Q_O2_consumption = -110 * 4184 # [kJ/kmol]
    dT_hx_loop = 8 # [degC]
    cooler_pressure_drop = 20684 # [Pa]
    compressor_isentropic_efficiency = 0.85
    V_max = 500 # [m3] #here cause pressure vessel design problem
    titer_LegH = 7.27 # [g / L]
    productivity_LegH = 7.27 / 72 # [g / L / h]
    Y_p = 7.27 * 4 / 1300 # [by wt] 3 wt%
    Y_b = 0.43 # [by wt] 
    yield_LegH = Y_p#/0.517 # yield based on glucose utilized for product formation
    titer_HemeB = 0.06632 # [g / L]
    productvitiy_HemeB = 0.06632 / 72


    """
    Reactions
    """
    
    # fermentation_reaction = bst.PRxn([
    #     #           Reaction        Reactnat            Conversion           Check                  "
    #     bst.Rxn('8 Glucose + 6 NH3 + 1 FeSO4 + 10.5 O2 -> Heme_b + 1 (NH4)2SO4 + 37 H2O + 14 CO2',
    #                                 reactant = 'Glucose',X=LegH_yield*0.05,check_atomic_balance=True),
    #     bst.Rxn('Glucose + (NH4)2SO4 + NH3 -> Globin + CO2 + H2O',
    #                                 reactant = 'Glucose', X= LegH_yield*0.05,correct_atomic_balance=True),
    #     bst.Rxn('Glucose + FeSO4 + (NH4)2SO4 + NH3 -> Leghemoglobin + CO2  + H2O',
    #                                 reactant = 'Glucose', X=LegH_yield,  correct_atomic_balance=True),
    #     ])
    fermentation_reaction = bst.PRxn([
        #           Reaction        Reactnat            Conversion           Check                  "
        bst.Rxn('1 Glucose + 1.05882 NH3 + 0.17647 FeSO4  -> 0.17647 Heme_b + 0.617647 O2 + 0.17647 (NH4)2SO4 + 4.05882 H2O',
                                    reactant = 'Glucose',X=yield_LegH*0.01,check_atomic_balance=True),
        bst.Rxn('Glucose + 0.01646 (NH4)2SO4 + 1.61317 NH3 -> 6 Globin + 0.28807 O2 + 3.68724 H2O',
                                    reactant = 'Glucose', X= yield_LegH*0.04,check_atomic_balance=True),
        bst.Rxn('Glucose + 0.00786 FeSO4 + 0.00786 (NH4)2SO4 + 1.58847 NH3 -> 6 Leghemoglobin + 0.30275 O2  + 3.70380 H2O',
                                    reactant = 'Glucose', X=yield_LegH,  check_atomic_balance=True),
        ])
    fermentation_reaction[2].product_yield('Leghemoglobin', basis='wt', product_yield=yield_LegH)

    neutralization_reaction = bst.Rxn(
        'H2SO4 + 2 NH3 -> (NH4)2SO4', reactant = 'NH3', X=1,
        check_atomic_balance=True
    )

    cell_growth_reaction = bst.Rxn(
        'Glucose + 0.8364 NH3 + 0.0108 (NH4)2SO4 -> 2.01 H2O + 0.106 O2 + 6 Pichia_pastoris', 'Glucose', X=(1-yield_LegH*1.1)*Y_b,
        correct_atomic_balance=True
    )
    cell_growth_reaction.product_yield('Pichia_pastoris', basis='wt', product_yield=(1-yield_LegH*1.1)*Y_b)

    respiration_reaction1 = bst.Rxn(
        'Glucose + 6 O2 -> 6 CO2 + 6 H2O', 'Glucose', 1 - Y_b,
        check_atomic_balance=True
    )

    respiration_reaction2 = bst.Rxn(
        'Glucose + 6 O2 -> 6 CO2 + 6 H2O', 'Glucose', 1 - cell_growth_reaction.X - fermentation_reaction[2].X * 1.1,
        check_atomic_balance=True
    )

    bst.settings.chemicals.set_alias('Pichia_pastoris', 'cellmass')
    RXN = bst.ReactionSystem(
        fermentation_reaction,
        bst.PRxn([cell_growth_reaction, respiration_reaction2])
    )
    RXN.show()

    """
    Upstream Process
    """
    M301 = bst.MixTank('M301', ins=[SeedIn1,'Water1'], outs='M301Out', tau=16)
    @M301.add_specification(run=True)
    def update_seed1_inputs():
        target_stream = bst.Stream(**s.SeedSolution1)
        SeedIn1.imass['Seed'] = target_stream.imass['Seed']
        M301.ins[1].imass['H2O'] = target_stream.imass['H2O']
        M301.ins[1].T = 25+273.15
    
    M302 = bst.MixTank('M302', ins=[SeedIn2,CultureIn,'Water2'], outs='M302Out', tau=16)
    @M302.add_specification(run=True)
    def update_culture_inputs():
        target_stream = bst.Stream(**s.SeedSolution2)
        SeedIn2.imass['Seed'] = target_stream.imass['Seed']
        M302.ins[2].imass['H2O'] = target_stream.imass['H2O']
        M302.ins[2].T = 25+273.15
        CultureIn.imass['Culture'] = target_stream.imass['SeedSolution']*(0.1+60+0.15191)/1000

    M303 = u.SeedHoldTank('M303', ins=[M301-0, M302-0], outs='M303Out')

    R301 = u.SeedTrain(
        'R301',
        ins=[M303-0],
        outs=[vent1, 'R301Out'],
        reactions=bst.PRxn([cell_growth_reaction, respiration_reaction1]),
        saccharification=None,
        T=32+273.15,
    )
    R301.add_specification(run=True)
    
    M304 = bst.MixTank('M304', ins=[Glucose,'Water3'], outs='M304Out', tau=16)
    
    @M304.add_specification(run=True)
    def update_water_content():
        M304.ins[1].imass['H2O'] = Glucose.imass['Glucose']/2
        M304.ins[1].T = 25+273.15
    
    T301 = bst.StorageTank('T301', ins=M304-0, outs='T301Out',tau=16*4+72)

    T302 = u.AmmoniaStorageTank('T302', ins=NH3_25wt, outs='T302Out')

    # checking more details...
    R302 = u.AeratedFermentation(
        'R302',
        ins=[R301-1, T301-0, T302-0, bst.Stream('FilteredAir', phase='g', P=2 * 101325)],
        outs=[vent2, 'Broth'],
        fermentation_reaction=fermentation_reaction,
        cell_growth_reaction=cell_growth_reaction,
        respiration_reaction=respiration_reaction2,
        neutralization_reaction=neutralization_reaction,
        design=design, method=method,theta_O2=theta_O2,
        V_max=V_max, Q_O2_consumption=Q_O2_consumption,
        dT_hx_loop=dT_hx_loop, T=T_operation,
        batch=True, reactions=RXN,
        kW_per_m3=agitation_power,
        tau=titer_LegH/productivity_LegH,
        cooler_pressure_drop=cooler_pressure_drop,
        compressor_isentropic_efficiency=compressor_isentropic_efficiency,
        P=1 * 101325,#optimize_power=True,
    )
    R302.target_titer = titer_LegH # g / L
    R302.target_productivity = productivity_LegH # g / L / h
    R302.target_yield = yield_LegH  # wt %

    @R302.add_specification(run=True)
    def update_reaction_time_and_yield():
        R302.tau = R302.target_titer / R302.target_productivity
        fermentation_reaction[2].product_yield('Leghemoglobin', basis='wt', product_yield=R302.target_yield)


    """
    Downstream process
    """
    S401 = u.CellDisruption(
        'S401',
        ins=R302-1,
        outs='DisruptedBroth',
    )

    S402 = u.Centrifuge(
        'S402',
        ins = S401-0,
        outs = ('Deposit', 'Supernatant'),
        moisture_content = 0.20,  # 20% moisture content in the final product
        split = (0, 0.995, 1, 1),
        order = ('Glucose','cellmass', 'Leghemoglobin_In','Globin_In'),
    )
    S402.add_specification(run=True)

    #S403 = bst.SolidsSeparator('S403', ins=S402-0, outs=(effluent1, 'S403Out'), split=(1) , moisture_content=0.01)
    S403 = bst.ScrewPress('S403', ins=S402-0, outs=('CellMassWaste', 'S403Out'), split=(0.999) , moisture_content=0.01)
    
    S404 = bst.Splitter('S404', ins=S402-1, outs=('ResidualCellMass', 'S404Out'), split=(0.999) , order=('cellmass',))

    # E401 = u.Evaporator(
    #     'E401',
    #     ins = S402-1,
    #     outs = ('E401Out',effluent2),
    #     P = (101325, 73581, 50892, 32777, 20000),  # Reduced to 3 effects to increase vessel size
    #     V = 0.1,  # Increased vapor fraction to create larger vessels
    #     V_definition = 'First-effect',  # Changed to overall for better load distribution
    # )
    # E401.add_specification(run=True)

    M401 = bst.MixTank('M401', ins=(DfUltraBuffer, 'Water4'), 
                    outs='M401Out', tau=1) 
    @M401.add_specification(run=True)
    def update_DfUltraBuffer_initial():
        M401.ins[1].imass['H2O'] = (S402-1).imass['H2O']*4
        M401.ins[0].imol['DfUltraBuffer'] = ((S402-1).imass['H2O']*4)*(0.025+0.01+0.001)/1000

    H401 = bst.HXutility(
        'H401',
        ins=M401-0,
        outs='H401Out',
        T=5+273.15,  # Cool to 5°C
        cool_only=True,
    )

    U401 = u.Diafiltration(
        'U401',
        ins = (S404-1, H401-0),
        outs = ('U401Out','PermeateWasteUltra'),
        TargetProduct_ID = 'Leghemoglobin',
        Salt_ID = c.chemical_groups['Salts'],
        OtherLargeMolecules_ID = c.chemical_groups['OtherLargeMolecules'],
        TMP_bar1 = 3 ,#2~4
        TMP_bar2 = 2 ,#1.5~3
    )
    U401.add_specification(run=True)

    #S404 = bst.SolidsSeparator('S404', ins=U401-1, outs=(effluent2, 'S404Out'), split=(1) , moisture_content=0.01)
    #S405 = u.ReverseOsmosis('S405', ins=U401-1, outs=('S405Out',effluent2))

    M402 = bst.MixTank('M402', ins=(IXEquilibriumBuffer,'Water5'), 
                    outs='M402Out', tau=1)
    M403 = bst.MixTank('M403', ins=(IXElutionBuffer,'Water6'),
                    outs='M403Out', tau=1)
    M404 = bst.MixTank('M404', ins=(IXRegenerationSolution,'Water7'), 
                    outs='M404Out', tau=1)

    H402 = bst.HXutility(
        'H402',
        ins=M402-0,
        outs='H402Out',
        T=5+273.15,  # Cool to 5°C
        cool_only=True,
    )
    H403 = bst.HXutility(
        'H403',
        ins=M403-0,
        outs='H403Out',
        T=5+273.15,  # Cool to 5°C
        cool_only=True,
    )
    H404 = bst.HXutility(
        'H404', 
        ins=M404-0,
        outs='H404Out',
        T=5+273.15,  # Cool to 5°C
        cool_only=True,
    )

    U402 = u.IonExchangeCycle(
        'U402',
        ins = (U401-0, H402-0, H403-0, H404-0),
        outs = ('U402Out','FlowthroughWaste','WashWaste','RegenerationWaste'),
        TargetProduct_IDs = c.chemical_groups['LegHIngredients'],
        BoundImpurity_IDs=c.chemical_groups['BoundImpurities'],
    )    

    @M402.add_specification(run=True)
    def update_IXEquilibriumBuffer_initial():
        M402.ins[1].imass['H2O'] = (U401-0).imass['H2O']*U402.wash_CV
        M402.ins[0].imol['IXEquilibriumBuffer'] = ((U401-0).imass['H2O']*U402.wash_CV)*(0.025+0.01+0.001)/1000
    @M403.add_specification(run=True)
    def update_IXElutionBuffer_initial():
        M403.ins[1].imass['H2O'] = (U401-0).imass['H2O']*U402.elution_CV
        M403.ins[0].imol['IXElutionBuffer'] = ((U401-0).imass['H2O']*U402.elution_CV)*(0.025+1+0.1)/1000
    @M404.add_specification(run=True)
    def update_IXRegenerationSolution_initial():
        M404.ins[1].imass['H2O'] = (U401-0).imass['H2O']*U402.regeneration_CV
        M404.ins[0].imol['NaOH'] = ((U401-0).imass['H2O']*U402.regeneration_CV)*(0.5)/1000

    #S405 = bst.SolidsSeparator('S405', ins=U402-1, outs=(effluent3, 'S405Out'), split=(1) , moisture_content=0.01)
    #S406 = u.ReverseOsmosis('S406', ins=U402-1, outs=('S406Out',effluent3))

    M405 = bst.MixTank('M405', ins=(DfNanoBuffer,'Water8'), 
                    outs='M405Out', tau=1)
    @M405.add_specification(run=True)
    def update_DfNanoBuffer_initial():
        M405.ins[1].imass['H2O'] = (U402-0).imass['H2O']*2
        M405.ins[0].imol['DfNanoBuffer'] = ((U402-0).imass['H2O']*2)*(0.01+0.01)/1000

    H405 = bst.HXutility(
        'H405',
        ins=M405-0,
        outs='H405Out',
        T=5+273.15,  # Cool to 5°C
        cool_only=True,
    )

    U403 = u.Diafiltration(
        'U403',
        ins = (U402-0, H405-0),
        outs = ('U403Out','PermeateWasteNano'),
        TargetProduct_ID = 'Leghemoglobin',
        membrane_cost_USD_per_m2=250, # Nanomembrane cost
        Salt_ID = c.chemical_groups['Salts'],
        OtherLargeMolecules_ID = c.chemical_groups['OtherLargeMolecules'],
        TargetProduct_Retention=0.995, Salt_Retention=0.001,
        OtherLargeMolecules_Retention=0.995, DefaultSolutes_Retention=0.015,
        FeedWater_Recovery_to_Permeate=0.75,
        TMP_bar1= 15 ,# 10-25
        TMP_bar2= 4  ,# 3-6
        membrane_flux_LMH=25, # 10-40
    )
    U403.add_specification(run=True)

    #S406 = bst.SolidsSeparator('S406', ins=U403-1, outs=(effluent4, 'S406Out'), split=(1) , moisture_content=0.01)
    #S407 = u.ReverseOsmosis('S407', ins=U403-1, outs=('S407Out',effluent4))

    U404 = u.Ultrafiltration(
        'U404',
        ins = (U403-0),
        outs = ( 'U404Out', 'PermeateWater'),
        TargetProduct_ID = 'Leghemoglobin',
        Salt_ID = c.chemical_groups['Salts'],
        OtherLargeMolecules_ID = c.chemical_groups['OtherLargeMolecules'],
        TMP_bar = 3,
        FeedWater_Recovery_to_Permeate = 0.75,  # Initial value, will be adjusted by spec
        )
    
    # Target specifications from check_legH_specifications
    U404.target_total_solids_percent = 12.0  # Target: 0-24%, aim for middle-low range
    U404.target_legh_percent = 7.5  # Target: 6-9%, aim for middle
    
    @U404.add_specification(run=False)
    def U404_adjust_water_recovery():
        """
        Dynamically adjust water recovery to achieve target total solids content
        while maintaining product specifications.
        """
        import flexsolve as flx
        import warnings
        
        feed_stream = U404.ins[0]
        product_stream = U404.outs[0]
        
        # Safety check: ensure feed has content
        if feed_stream.F_mass <= 0:
            U404._run()
            return
        
        # Calculate initial solids content in feed
        feed_total_mass = feed_stream.F_mass
        feed_water_mass = feed_stream.imass['H2O']
        feed_solids_mass = feed_total_mass - feed_water_mass
        
        if feed_solids_mass <= 0:
            print(f"   [{U404.ID}] Warning: No solids in feed stream")
            U404._run()
            return
        
        # Define objective function: adjust recovery to hit target solids %
        def calculate_total_solids_error(water_recovery):
            """
            Calculate error between actual and target total solids percentage.
            
            Parameters
            ----------
            water_recovery : float
                Fraction of water removed to permeate (0-0.95)
            
            Returns
            -------
            float
                Error = (actual_solids% - target_solids%) [%]
            """
            # Ensure water recovery is within reasonable bounds
            water_recovery = max(0.05, min(0.95, water_recovery))
            
            # Set recovery and run unit (warnings suppressed by outer context)
            U404.FeedWater_Recovery_to_Permeate = water_recovery
            U404._run()
            
            # Calculate total solids percentage in retentate (product)
            product_total_mass = product_stream.F_mass
            
            if product_total_mass <= 0:
                return 100.0  # Large error if no product
            
            product_water_mass = product_stream.imass['H2O']
            product_solids_mass = product_total_mass - product_water_mass
            
            actual_solids_percent = (product_solids_mass / product_total_mass) * 100
            
            return actual_solids_percent - U404.target_total_solids_percent
        
        try:
            # Suppress warnings during optimization
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                
                # Use IQ_interpolation to find optimal water recovery
                optimal_recovery = flx.IQ_interpolation(
                    f=calculate_total_solids_error,
                    x0=0.10,  # Minimum recovery (keep more water)
                    x1=0.95,  # Maximum recovery (remove more water)
                    x=U404.FeedWater_Recovery_to_Permeate,  # Initial guess
                    xtol=0.001,  # 1% tolerance on recovery
                    ytol=0.05,   # 0.05% tolerance on solids content
                    maxiter=50,
                )
        
            # Set optimal recovery and run final time (warnings enabled)
            U404.FeedWater_Recovery_to_Permeate = optimal_recovery
            U404._run()
            
            # Verify final product specifications
            product_total_mass = product_stream.F_mass
            product_water_mass = product_stream.imass['H2O']
            product_solids_mass = product_total_mass - product_water_mass
            product_legh_mass = product_stream.imass['Leghemoglobin']
            
            actual_solids_percent = (product_solids_mass / product_total_mass) * 100
            actual_legh_percent = (product_legh_mass / product_total_mass) * 100
            
            # Print results
            print(f"   [{U404.ID}] Optimized water recovery: {optimal_recovery:.3f}")
            print(f"   [{U404.ID}] Total solids: {actual_solids_percent:.2f}% "
                  f"(target: {U404.target_total_solids_percent:.2f}%)")
            print(f"   [{U404.ID}] Leghemoglobin: {actual_legh_percent:.2f}% "
                  f"(target: {U404.target_legh_percent:.2f}%)")
            
            # Warning if specifications are not met
            if actual_solids_percent > 24.0:
                print(f"   [{U404.ID}] WARNING: Total solids {actual_solids_percent:.2f}% "
                      f"exceeds maximum 24%")
            if actual_legh_percent < 6.0 or actual_legh_percent > 9.0:
                print(f"   [{U404.ID}] WARNING: Leghemoglobin {actual_legh_percent:.2f}% "
                      f"outside target range 6-9%")
        
        except Exception as e:
            print(f"   [{U404.ID}] Specification optimization failed: {e}")
            print(f"   [{U404.ID}] Using default recovery: {U404.FeedWater_Recovery_to_Permeate:.3f}")
            U404._run()

    # S408 = bst.SprayDryer(
    #     'S408', 
    #     ins=U403-0,
    #     outs=('EvaporatedWater', 'S408Out'),
    #     moisture_content=0.90,  # 90% moisture content in the final product
    # )
    # S408.add_specification(run=True)

    M501 = bst.MixTank('M501', ins=(S403-1,U401-1,U402-1,U402-2,U403-1,U404-1), 
                    outs='M501Out', tau=1)
    M501.add_specification(run=True)

    T501 = u.SulfuricAcidStorageTank('T501', 
                        ins=bst.Stream('SulfuricAcid', H2SO4=0.98,H2O=0.02, 
                        units='kg/hr', price=price['H2SO4']), 
                        outs='T501Out')
    @T501.add_specification(run=True)
    def update_acid_flowrate():
        T501.ins[0].imol['H2SO4'] = U402.outs[3].imol['NaOH']/2*1.001
        T501.ins[0].T = 25+273.15

    M502 = bst.NeutralizationTank1('M502', ins=(U402-3,T501-0), outs='M502Out', T=20+273.15)

    S501 = u.ReverseOsmosis('S501', ins=M501-0, outs=('RO_treated_water1', effluent1))
    # effluent2 to neutralization and then to biological treatment

    S502 = bst.Splitter('S502', ins=M502-0, outs=('SaltWaste', effluent2), split=[0.99,0.99,0.99], order=['H2O','Na2SO4','NaHSO4'])

    S503 = u.ReverseOsmosis('S503', ins=S502-0, outs=('RO_treated_water2', effluent3))

    H406 = bst.HXutility(
        'H406',
        ins=U404-0,
        outs=LegH_3,
        T=0+273.15,  # Cool to 0°C
        cool_only=True,
    )

    # # ### Facilities ###
    CT = bst.CoolingTower(500 if use_area_convention else 'CT')
    CWP = bst.ChilledWaterPackage(500 if use_area_convention else 'CWP')

    #ADP = bst.AirDistributionPackage(500 if use_area_convention else 'ADP')

    BT = bst.BoilerTurbogenerator(400 if use_area_convention else 'BT',
        (S403-0, 'gas_to_boiler', 'boiler_makeup_water', 'natural_gas', 'lime_boiler', 'boiler_chems'),
        outs=('emissions', 'rejected_water_and_blowdown', 'ash_disposal'),
        boiler_efficiency=0.80,
        turbogenerator_efficiency=0.85,
        satisfy_system_electricity_demand=False,
    )

    makeup_water_streams = (F.cooling_tower_makeup_water,
                            F.Water1, F.Water2,
                            F.Water3, F.Water4,
                            F.Water5, F.Water6,
                            F.Water7, F.Water8,
                            F.boiler_makeup_water)
    process_water_streams = (F.S501.outs[1],F.S503.outs[1],
                            *makeup_water_streams)

    makeup_water = bst.Stream('makeup_water', price=0.000254)

    PWC = bst.ProcessWaterCenter(500 if use_area_convention else 'PWC',
        ins=('recycled_RO_water', makeup_water, 'recycled_process_water', 'makeup_process_water'),
        outs=('RO_water', 'process_water', 'excess_water'),
        makeup_water_streams=makeup_water_streams,
        process_water_streams=process_water_streams,
        reverse_osmosis_water_price=0.000254,  # USD/kg
        process_water_price=0.000135,  # USD/kg
    )
    # HXN = bst.HeatExchangerNetwork(600 if use_area_convention else 'HXN')
    # load_process_settings()  # Load process settings to update prices and CFs
    s.update_all_input_stream_prices(streamlist=[SeedIn1, SeedIn2, CultureIn, Glucose, NH3_25wt, DfUltraBuffer, IXEquilibriumBuffer, IXElutionBuffer, IXRegenerationSolution, DfNanoBuffer])

    return LegH_3, vent1, vent2, effluent1, effluent2,effluent3, DfUltraBuffer, IXEquilibriumBuffer, IXElutionBuffer, IXRegenerationSolution, DfNanoBuffer

# %% Design Specification Functions


def set_production_rate(system, target_production_rate_kg_hr):
    """
    Adjust system inputs to achieve target LegH_3 production rate using a global scaling factor.
    
    Parameters
    ----------
    system : biosteam.System
        The LegH production system
    target_production_rate_kg_hr : float
        Target mass flow rate for LegH_3 stream [kg/hr]
    
    Returns
    -------
    float
        Achieved production rate [kg/hr]
    """
    import flexsolve as flx
    import warnings
    
    # Get product stream
    product_stream = system.flowsheet.stream.LegH_3
    
    # Store baseline flow rates for all input streams
    baseline_flows = {}
    for stream in system.ins:
        if stream.F_mass > 0:
            baseline_flows[stream] = stream.F_mass
    
    if not baseline_flows:
        raise ValueError("No input streams with positive flow rates found")
    
    print(f"\n{'='*60}")
    print(f"Setting Production Rate to {target_production_rate_kg_hr:.2f} kg/hr")
    print(f"{'='*60}")
    print(f"Baseline input streams stored: {len(baseline_flows)} streams")
    
    # Run initial simulation to get baseline
    print("Running initial simulation to establish baseline...")
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        system.simulate()
    
    initial_production = product_stream.F_mass
    
    if initial_production <= 0:
        raise ValueError("Initial production rate is zero. Cannot scale system.")
    
    # Calculate initial scaling factor guess
    initial_guess = target_production_rate_kg_hr / initial_production
    
    print(f"  Initial production: {initial_production:.2f} kg/hr")
    print(f"  Target production:  {target_production_rate_kg_hr:.2f} kg/hr")
    print(f"  Initial scaling guess: {initial_guess:.4f}x")
    print(f"  Search bounds: 0.1x to 5.0x baseline")
    
    # Iteration tracking
    iteration = [0]
    
    # Define objective function that scales inputs, simulates, and returns error
    def objective_function(scaling_factor):
        """
        Scale all input streams, simulate system, return production error.
        
        Parameters
        ----------
        scaling_factor : float
            Global scaling factor for all inputs
            
        Returns
        -------
        float
            Error = (achieved_production - target_production) [kg/hr]
        """
        iteration[0] += 1
        
        try:
            # Scale all input streams
            for stream, baseline_flow in baseline_flows.items():
                stream.F_mass = baseline_flow * scaling_factor
            
            # Simulate system with scaled inputs (warnings suppressed by outer context)
            system.simulate()
            
            # Get achieved production rate
            achieved_rate = product_stream.F_mass
            error = achieved_rate - target_production_rate_kg_hr
            
            # Print progress (only every 5 iterations to reduce clutter)
            if iteration[0] % 5 == 0 or abs(error) < 1.0:
                print(f"    Iteration {iteration[0]}: scale={scaling_factor:.4f}x, "
                      f"production={achieved_rate:.2f} kg/hr, error={error:.4f} kg/hr")
            
            return error
            
        except Exception as e:
            print(f"    Iteration {iteration[0]} FAILED at scale={scaling_factor:.4f}x: {e}")
            # Return large error to guide solver away from infeasible region
            return 1e6 if scaling_factor > initial_guess else -1e6
    
    try:
        print(f"\nSolving for optimal scaling factor (intermediate warnings suppressed)...")
        
        # Suppress all warnings during the iterative solving process
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            
            # Use flexsolve directly (not as a system specification)
            scaling_factor = flx.IQ_interpolation(
                f=objective_function,
                x0=0.1,              # Lower bound
                x1=5.0,              # Upper bound
                x=initial_guess,     # Initial guess
                xtol=0.0001,         # Tolerance on scaling factor
                ytol=0.01,           # Tolerance on production rate [kg/hr]
                maxiter=100,
                checkbounds=True,
                checkiter=True,
            )
        
        # After solver converges, run final simulation WITHOUT suppressing warnings
        # This allows any persistent issues to be displayed
        print(f"\nSolver converged. Running final validation simulation...")
        for stream, baseline_flow in baseline_flows.items():
            stream.F_mass = baseline_flow * scaling_factor
        
        # Final simulation with warnings enabled
        system.simulate()
        
        achieved_rate = product_stream.F_mass
        
        print(f"\n✓ Successfully achieved production rate:")
        print(f"  Target:          {target_production_rate_kg_hr:.2f} kg/hr")
        print(f"  Achieved:        {achieved_rate:.2f} kg/hr")
        print(f"  Scaling factor:  {scaling_factor:.4f}x")
        print(f"  Error:           {abs(achieved_rate - target_production_rate_kg_hr):.4f} kg/hr")
        print(f"  Total iterations: {iteration[0]}")
        print(f"{'='*60}\n")
        
        return achieved_rate
        
    except Exception as e:
        print(f"\n✗ Failed to achieve target production rate: {e}")
        print(f"  Error type: {type(e).__name__}")
        print(f"  Total iterations attempted: {iteration[0]}")
        
        # Restore baseline flows
        print(f"\n  Restoring baseline input flows...")
        for stream, baseline_flow in baseline_flows.items():
            stream.F_mass = baseline_flow
        
        # Run one final simulation with baseline flows (warnings enabled)
        try:
            system.simulate()
            print(f"  System restored to baseline: {product_stream.F_mass:.2f} kg/hr")
        except Exception as restore_error:
            print(f"  Warning: Could not restore baseline simulation: {restore_error}")
        
        raise ValueError(f"Could not achieve target production rate of {target_production_rate_kg_hr:.2f} kg/hr: {e}")


def check_LegH_specifications(product_stream):
    """
    Verify that LegH_3 product stream meets composition and purity specifications.
    
    Parameters
    ----------
    product_stream : thermosteam.Stream
        The LegH_3 product stream to check
    
    Raises
    ------
    ValueError
        If any specification is not met
    """
    print(f"\n{'='*60}")
    print(f"Product Specification Check: {product_stream.ID}")
    print(f"{'='*60}")
    
    # Get total mass
    total_mass = product_stream.F_mass
    
    if total_mass <= 0:
        raise ValueError("Product stream has zero mass flow")
    
    # Helper function to safely get mass of chemicals
    def get_chemical_mass(chemical_id):
        """Safely get mass of a chemical, return 0 if not present"""
        try:
            return product_stream.imass[chemical_id]
        except:
            return 0
    
    # Calculate mass fractions (as percentages)
    def get_mass_percent(chemical_ids):
        """Get total mass percent for list of chemicals"""
        if isinstance(chemical_ids, str):
            chemical_ids = [chemical_ids]
        total = sum(get_chemical_mass(chem) for chem in chemical_ids)
        return total / total_mass * 100
    
    # Define specifications
    specs = {
        'Fat (OleicAcid)': {
            'chemicals': ['OleicAcid'],
            'target': (0, 2),
            'actual': None
        },
        'Carbohydrates': {
            'chemicals': ['Glucan', 'Glucose', 'Chitin'],
            'target': (0, 4),
            'actual': None
        },
        'Product (Leghemoglobin)': {
            'chemicals': ['Leghemoglobin'],
            'target': (6, 9),
            'actual': None
        },
        'Total Solids': {
            'chemicals': [chem for chem in product_stream.chemicals.IDs if chem != 'H2O'],
            'target': (0, 24),
            'actual': None
        }
    }
    
    # Calculate actual values
    for spec_name, spec_data in specs.items():
        spec_data['actual'] = get_mass_percent(spec_data['chemicals'])
    
    # Calculate protein purity
    legh_mass = get_chemical_mass('Leghemoglobin')
    globin_mass = get_chemical_mass('Globin')
    mannoprotein_mass = get_chemical_mass('Mannoprotein')
    total_protein_mass = legh_mass + globin_mass + mannoprotein_mass
    
    protein_purity = (legh_mass / total_protein_mass * 100) if total_protein_mass > 0 else 0
    
    # Print results
    all_passed = True
    
    print(f"\n{'Specification':<30} {'Target Range':<25} {'Actual':<15} {'Status'}")
    print(f"{'-'*85}")
    
    for spec_name, spec_data in specs.items():
        min_val, max_val = spec_data['target']
        actual = spec_data['actual']
        passed = min_val <= actual <= max_val
        
        status = '✓ PASS' if passed else '✗ FAIL'
        target_str = f"{min_val:.1f}% - {max_val:.1f}%"
        print(f"{spec_name:<30} {target_str:<25} {actual:>6.2f}%{'':<7} {status}")
        
        if not passed:
            all_passed = False
    
    # Check protein purity
    purity_passed = protein_purity >= 65.0
    status = '✓ PASS' if purity_passed else '✗ FAIL'
    print(f"{'Protein Purity':<30} {'>= 65.0%':<25} {protein_purity:>6.2f}%{'':<7} {status}")
    
    if not purity_passed:
        all_passed = False
    
    print(f"{'='*85}")
    
    # Additional info
    print(f"\nProduct Stream Summary:")
    print(f"  Total Flow Rate: {total_mass:.2f} kg/hr")
    print(f"  Water Content:   {get_mass_percent('H2O'):.2f}%")
    print(f"  Leghemoglobin:   {legh_mass:.4f} kg/hr ({get_mass_percent('Leghemoglobin'):.2f}%)")
    
    if not all_passed:
        print(f"\n{'='*85}")
        raise ValueError("Product does not meet one or more specifications. See details above.")
    
    print(f"\n✓ All specifications met!")
    print(f"{'='*85}\n")
    
    return True


# %%
if __name__ == '__main__':
    # Set preferences
    bst.preferences.N = 50
    nn=1
    # Define target production rate
    TARGET_PRODUCTION = 275 * nn # kg/hr
    
    print("="*85)
    print("LEGHEMOGLOBIN PRODUCTION SYSTEM - DESIGN SPECIFICATION MODE")
    print("="*85)
    
    # Create the LegH system
    print("\n1. Creating system...")
    LegH_sys = create_LegH_system()
    sys = LegH_sys
    f = sys.flowsheet
    u = f.unit
    ss = f.stream
    sys.operating_hours = 8000
    
    # Run initial baseline simulation
    print("\n2. Running baseline simulation...")
    try:
        LegH_sys.simulate()
        baseline_production = ss.LegH_3.F_mass
        print(f"   Baseline production rate: {baseline_production:.2f} kg/hr")
    except Exception as e:
        print(f"   Baseline simulation failed: {e}")
        raise
    
    # Set production rate to target using design specification
    print(f"\n3. Applying design specification: TARGET_PRODUCTION = {TARGET_PRODUCTION} kg/hr")
    try:
        achieved_production = set_production_rate(LegH_sys, TARGET_PRODUCTION)
        
        # Verify production rate is maintained
        LegH_sys.simulate()
        final_production = ss.LegH_3.F_mass
        
        if abs(final_production - TARGET_PRODUCTION) > 1.0:  # Allow 1 kg/hr tolerance
            print(f"\n   WARNING: Production rate drifted after final simulation!")
            print(f"   Target:  {TARGET_PRODUCTION:.2f} kg/hr")
            print(f"   Actual:  {final_production:.2f} kg/hr")
            
    except Exception as e:
        print(f"\n   Could not achieve target production: {e}")
        print("   Continuing with baseline production rate...")
        achieved_production = ss.LegH_3.F_mass
    
    # Check product specifications
    print(f"\n4. Verifying product specifications...")
    try:
        check_LegH_specifications(ss.LegH_3)
    except ValueError as e:
        print(f"\n   SPECIFICATION CHECK FAILED: {e}")
        print("   System may require process parameter adjustments to meet specifications.")
    
    # Display system results
    print(f"\n5. System Summary")
    print("="*85)
    LegH_sys.show()
    
    # Calculate key metrics
    legh_purity = ss.LegH_3.imass['Leghemoglobin'] / ss.LegH_3.F_mass * 100
    print(f"\n{'='*85}")
    print("KEY PERFORMANCE INDICATORS")
    print(f"{'='*85}")
    print(f"  Product Stream:           {ss.LegH_3.ID}")
    print(f"  Production Rate:          {ss.LegH_3.F_mass:.2f} kg/hr")
    print(f"  Leghemoglobin Content:    {legh_purity:.2f}%")
    print(f"  Annual Production:        {ss.LegH_3.F_mass * sys.operating_hours / 1000:.2f} metric tons/year")
    print(f"{'='*85}\n")
    
    # Generate system diagram
    print(f"\n6. Generating system diagram...")
    LegH_sys.diagram(format='html', display=True)
    
    # LCA analysis
    print(f"\n7. Performing LCA analysis...")
    try:
        r1 = bst.report.lca_inventory_table(
            systems=[sys],
            keys='GWP',
            items=[ss.LegH_3],
        )
        print("   LCA Inventory Table generated")
        
        r2 = bst.report.lca_displacement_allocation_table(
            systems=[sys],
            key='GWP',
            items=[ss.LegH_3],
        )
        print("   LCA Displacement Allocation Table generated")
    except Exception as e:
        print(f"   LCA analysis failed: {e}")
    
    print(f"\n{'='*85}")
    print("SIMULATION COMPLETE")
    print(f"Target Production:   {TARGET_PRODUCTION:.2f} kg/hr")
    print(f"Achieved Production: {ss.LegH_3.F_mass:.2f} kg/hr")
    print(f"{'='*85}\n")



================ FILE: LegH\tea.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-07-02 15:20:03

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

from biorefineries.corn import tea
import biosteam as bst
import numpy as np
import pandas as pd
from biorefineries.tea.conventional_ethanol_tea import *
# bst.nbtutorial()
from numba import njit
from numpy import ndarray as NDArray

@njit(cache=True)
def generate_DDB_schedule(years):
    val = 1.
    arr = np.ones(years)
    factor = 2. / years
    for i in range(years):
        depreciation = val * factor
        arr[i] = depreciation
        val -= depreciation
    return arr
    
@njit(cache=True)
def generate_SYD_schedule(years):
    digit_sum = years * (years + 1.) * 0.5
    arr = np.ones(years)
    for i in range(years):
        arr[i] = (years - i) / digit_sum
    return arr

class PreFerSTEA(bst.TEA):

    def __init__(self, system, IRR, duration, depreciation, income_tax,
                operating_days, lang_factor, construction_schedule, WC_over_FCI,
                labor_cost, fringe_benefits, property_tax,
                property_insurance, supplies, maintenance, administration,
                target_production_kg_hr=None):
        # Huang et. al. does not take into account financing or startup
        # so these parameters are 0 by default
        super().__init__(system, IRR, duration, depreciation, income_tax,
                        operating_days, lang_factor, construction_schedule,
                        startup_months=6, startup_FOCfrac=0.9, startup_VOCfrac=0.4,
                        startup_salesfrac=0.4, finance_interest=0.05, finance_years=10,
                        finance_fraction=0.7, WC_over_FCI=WC_over_FCI)
        self.labor_cost = labor_cost
        self.fringe_benefits = fringe_benefits
        self.property_tax = property_tax
        self.property_insurance = property_insurance
        self.supplies= supplies
        self.maintenance = maintenance
        self.administration = administration
        
        # Store target production rate
        self._target_production_kg_hr = target_production_kg_hr

    depreciation_schedules: dict[tuple[str, int], NDArray[float]] = {

        ('MACRS', 3): np.array([.3333, .4445, .1481, .0741]),

        ('MACRS', 5): np.array([.2000, .3200, .1920,
                                .1152, .1152, .0576]),

        ('MACRS', 7):  np.array([.1429, .2449, .1749,
                                 .1249, .0893, .0892,
                                 .0893, .0446]),
        
        ('MACRS', 10): np.array([.1000, .1800, .1440,
                                 .1152, .0922, .0737,
                                 .0655, .0655, .0656,
                                 .0655, .0328]),
      
        ('MACRS', 15): np.array([.0500, .0950, .0855,
                                 .0770, .0693, .0623,
                                 .0590, .0590, .0591,
                                 .0590, .0591, .0590,
                                 .0591, .0590, .0591,
                                 .0295]),
      
        ('MACRS', 20): np.array([0.03750, 0.07219, 0.06677,
                                 0.06177, 0.05713, 0.05285,
                                 0.04888, 0.04522, 0.04462,
                                 0.04461, 0.04462, 0.04461,
                                 0.04462, 0.04461, 0.04462,
                                 0.04461, 0.04462, 0.04461,
                                 0.04462, 0.04461, 0.02231]),
                            
        ('IRAS', 1): np.array([1.0]),

        ('IRAS', 2): np.array([0.75, 0.25]),

        ('IRAS', 3): np.array([0.3333, 0.3333, 0.3334]),

        # This method involves a 20% initial allowance in the first year, with the remaining 80% written off over the asset's life.
        # The prescribed working lives are simplified into 6, 12, or 16 years.
        ('IRAS', 6): np.array([0.3333, 0.1333, 0.1333, 0.1333, 0.1334, 0.1334]),

        ('IRAS', 12): np.array([0.2667, 0.0667, 0.0667, 0.0667, 0.0667, 0.0667,
                            0.0667, 0.0667, 0.0667, 0.0667, 0.0667, 0.0666]),

        ('IRAS', 16): np.array([0.25, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05,
                            0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05])
    }

    @property
    def depreciation(self) -> str|NDArray[float]:
        """
        Depreciation schedule array or a string with format '{schedule}{years}', 
        where years is the number of years until the property value is zero 
        and schedule is one of the following: 'MACRS' (Modified Accelerated Cost Recovery System), 
        'SL' (straight line), 'DDB' (double declining balance), or 
        'SYD' (sum-of-the-years' digits). If years is not given, it defaults 
        to the venture years at run time.
        """
        return self._depreciation
    @depreciation.setter
    def depreciation(self, depreciation):
        if isinstance(depreciation, str):
            self._depreciation_key = self._depreciation_key_from_name(depreciation)
            self._depreciation = depreciation
        else:
            try:
                self._depreciation = np.array(depreciation, dtype=float)
            except:
                raise TypeError(
                   f"invalid depreciation type '{type(depreciation).__name__}'; "
                    "depreciation must be either an array or a string"
                ) from None
            else:
                self._depreciation_key = None
    
    @classmethod
    def _depreciation_key_from_name(cls, name):
        for prefix in ('MACRS', 'SL', 'DDB', 'SYD', 'IRAS'):
            if name.startswith(prefix):
                years = name[len(prefix):]
                key = (prefix, int(years) if years else None)
                if prefix == 'MACRS' and key not in cls.depreciation_schedules:
                    raise ValueError(
                        f"depreciation name {repr(name)} has a valid "
                         "format, but is not yet implemented in BioSTEAM"
                    )
                return key
        raise ValueError(
               f"invalid depreciation name {repr(name)}; "
                "name must have format '{schedule}{years}', "
                "where years is the number of years until the property value is zero "
                "and schedule is one of the following: 'MACRS' (Modified Accelerated Cost Recovery System), "
                "'SL' (straight line), 'DDB' (double declining balance), or "
                "'SYD' (sum-of-the-years' digits)"
            )

    @classmethod
    def _depreciation_array_from_key(cls, key):
        depreciation_schedules = cls.depreciation_schedules
        if key in depreciation_schedules:
            return depreciation_schedules[key]
        else:
            schedule, years = key
            if schedule == 'SL':
                arr = np.full(years, 1./years)
            elif schedule == 'DDB':
                arr = generate_DDB_schedule(years)
            elif schedule == 'SYD':
                arr = generate_SYD_schedule(years)
            else: # pragma: no cover
                raise RuntimeError(f'unknown depreciation schedule {repr(schedule)}')
            depreciation_schedules[key] = arr
            return arr

    # The abstract _FOC method should take fixed capital investment
    # and return the fixed operating cost.
    def _FOC(self, FCI):
        return (self.purchase_cost*(self.property_tax + self.property_insurance
                    + self.maintenance + self.administration)
                + self.labor_cost*(1+self.fringe_benefits+self.supplies))
    
    def CAPEX_table(self):
        purchase_cost = self.purchase_cost /1e6
        lang_factor = self.lang_factor
        if lang_factor is None:
            FCI = purchase_cost
        else:
            FCI = lang_factor * purchase_cost
        working_capital = FCI * self.WC_over_FCI
        TCI = FCI + working_capital
        accounting = self.Accounting(units='MM$')
        accounting.entry('Purchase cost', purchase_cost)
        accounting.entry('Fixed capital investment (FCI)', FCI, f"Purchase cost x {lang_factor}")
        accounting.entry('Working capital',  working_capital, f"{self.WC_over_FCI:.1%} of FCI")
        accounting.entry('Total capital investment (TCI)',  TCI, "Working capital + FCI")
        return accounting.table()
    
    def FOC_table(self):
        accounting = self.Accounting(units='MM$ / yr')
        FCI = self.purchase_cost / 1e6
        labor_cost = self.labor_cost / 1e6
        labor_burden = self.fringe_benefits + self.supplies
        accounting.entry('Labor salary', np.array(labor_cost))
        accounting.entry('Labor burden', np.array(labor_cost * labor_burden), f'{labor_burden:.0%} of labor salary')
        accounting.entry('Maintenance', np.array(self.maintenance * FCI), f'{self.maintenance:.0%} of FCI')
        accounting.entry('Administration', np.array(self.administration * FCI), f'{self.administration:.1%} of FCI')
        accounting.entry('Property tax', np.array(self.property_tax * FCI), f'{self.property_tax:.1%} of FCI')
        accounting.entry('Property insurance', np.array(self.property_insurance * FCI), f'{self.property_insurance:.1%} of FCI')
        return accounting.table()
    
    def set_production_rate(self, target_production_kg_hr):
        """
        Set the target production rate and adjust system inputs accordingly.
        
        Parameters
        ----------
        target_production_kg_hr : float
            Target production rate in kg/hr for LegH_3 stream
            
        Returns
        -------
        float
            Achieved production rate [kg/hr]
        """
        # Import the function from LegH module
        from biorefineries.prefers.LegH.system import set_production_rate
        
        self._target_production_kg_hr = target_production_kg_hr
        
        # Call the design specification function
        achieved_production = set_production_rate(self.system, target_production_kg_hr)
        
        return achieved_production
    
    def check_product_specifications(self):
        """
        Check if the product stream meets all specifications.
        
        Returns
        -------
        bool
            True if all specifications are met
            
        Raises
        ------
        ValueError
            If any specification is not met
        """
        # Import the function from LegH module
        from biorefineries.prefers.LegH.system import check_LegH_specifications
        
        # Get the product stream (LegH_3)
        product_stream = self.system.flowsheet.stream.LegH_3
        
        # Check specifications
        return check_LegH_specifications(product_stream)
    
    @property
    def target_production_kg_hr(self):
        """Target production rate in kg/hr"""
        return self._target_production_kg_hr
    
    @target_production_kg_hr.setter
    def target_production_kg_hr(self, value):
        """Set target production rate and adjust system"""
        if value is not None:
            self.set_production_rate(value)
        else:
            self._target_production_kg_hr = None
    
    # S-curve 0.10, 0.6, 0.3
    # Food tech 0.15，0.60， 0.25
    # Pharmaceutical 0.25, 0.50, 0.25
    # Biochemical 0.10, 0.65, 0.25
    # agri food 0.1 0.35 0.4 0.15

# %%
if __name__ == '__main__':
    import biosteam as bst
    from biorefineries.prefers.LegH.system import create_LegH_system
    from biorefineries.prefers.process_settings import load_process_settings
    from biosteam import settings
    
    print("="*85)
    print("LEGHEMOGLOBIN TEA - WITH DESIGN SPECIFICATION")
    print("="*85)
    
    # Load process settings
    load_process_settings()
    
    # Create system
    print("\n1. Creating LegH system...")
    LegH_sys = create_LegH_system()
    LegH_sys.operating_hours = 8000
    
    # Define target production rate
    TARGET_PRODUCTION = 275 * 1  # kg/hr
    
    print(f"\n2. Running baseline simulation...")
    LegH_sys.simulate()
    baseline_production = LegH_sys.flowsheet.stream.LegH_3.F_mass
    print(f"   Baseline production: {baseline_production:.2f} kg/hr")
    
    # Create TEA object WITH target production rate
    print(f"\n3. Creating TEA with target production = {TARGET_PRODUCTION} kg/hr...")
    LegH_tea = PreFerSTEA(
        system=LegH_sys, 
        IRR=0.18, 
        duration=(2024, 2044), 
        depreciation='IRAS6',
        income_tax=0.17, 
        operating_days=333, 
        lang_factor=None,
        construction_schedule=(0.15, 0.60, 0.25), 
        WC_over_FCI=0.15,
        labor_cost=10*6e4, 
        fringe_benefits=0.17+0.07, 
        property_tax=0.005,
        property_insurance=0.005, 
        supplies=0.02, 
        maintenance=0.03,
        administration=0.05,
        target_production_kg_hr=TARGET_PRODUCTION  # SET PRODUCTION RATE HERE
    )
    
    # Set production rate using the TEA method
    print(f"\n4. Adjusting system to target production rate...")
    achieved_production = LegH_tea.set_production_rate(TARGET_PRODUCTION)
    
    # Verify specifications
    print(f"\n5. Checking product specifications...")
    try:
        LegH_tea.check_product_specifications()
        print("   ✓ All specifications met!")
    except ValueError as e:
        print(f"   ✗ Specification check failed: {e}")
    
    # Get product stream
    products = LegH_sys.flowsheet.stream.LegH_3
    
    print(f"\n{'='*85}")
    print("TEA RESULTS")
    print(f"{'='*85}")
    
    # Calculate annual production
    annual_production_kg = products.F_mass * LegH_sys.operating_hours
    annual_production_MT = annual_production_kg / 1000
    
    print(f"\nProduction Summary:")
    print(f"  Hourly production:  {products.F_mass:.2f} kg/hr")
    print(f"  Annual production:  {annual_production_MT:.2f} metric tons/year")
    print(f"  Operating hours:    {LegH_sys.operating_hours} hr/year")
    
    # %%
    print(f"\n{'='*85}")
    LegH_tea.show()  # Display the TEA summary
    
    # %%
    print(f"\n{'='*85}")
    print("CASH FLOW TABLE")
    print(f"{'='*85}")
    cashflow_table = LegH_tea.get_cashflow_table()
    print(cashflow_table)
    #cashflow_table.to_excel('LegH_cashflow_table.xlsx',index=True)
    
    # %%
    print(f"\n{'='*85}")
    print("MINIMUM SELLING PRICE")
    print(f"{'='*85}")
    price = LegH_tea.solve_price(products) # USD/kg
    print(f"  LegH MPSP: ${price:.4f}/kg")
    print(f"  LegH MPSP: ${price*1000:.2f}/metric ton")
    annual_revenue = price * annual_production_kg
    print(f"  Annual revenue (at MPSP): ${annual_revenue/1e6:.2f} million")
    
    # %%
    print(f"\n{'='*85}")
    print("COST BREAKDOWN TABLES")
    print(f"{'='*85}")
    
    from biorefineries.prefers import _table as tb
    
    print("\nAll Cost Table:")
    df1 = tb.all_cost_table(LegH_tea)
    print(df1)
    #df1.to_excel('LegH_cost_table.xlsx',index=True)
    
    # %%
    print("\nVariable Operating Costs:")
    df2 = bst.report.voc_table(LegH_sys, 'LegH_3')
    print(df2)
    #df2.to_excel('LegH_voc_table.xlsx',index=True)
    
    # %%
    print("\nCAPEX Breakdown:")
    df8 = LegH_tea.CAPEX_table()
    print(df8)
    #df8.to_excel('LegH_CAPEX_table.xlsx',index=True)
    
    # %%
    print("\nFixed Operating Costs:")
    df9 = LegH_tea.FOC_table()
    print(df9)
    #df9.to_excel('LegH_FOC_table.xlsx',index=True)
    
    # %%
    print(f"\n{'='*85}")
    print("UNIT OPERATION TABLES")
    print(f"{'='*85}")
    
    print("\nReaction Tables:")
    df3 = bst.report.unit_reaction_tables(LegH_sys.units)
    print(df3)
    #df3.to_excel('LegH_reaction_table.xlsx',index=True)
    
    # %%
    print("\nUnit Results:")
    df4 = bst.report.unit_result_tables(LegH_sys.units)
    print(df4)
    #df4.to_excel('LegH_result_table.xlsx',index=True)
    
    # %%
    print(f"\n{'='*85}")
    print("UTILITY TABLES")
    print(f"{'='*85}")
    
    print("\nHeat Utilities:")
    df5 = bst.report.heat_utility_tables(LegH_sys.units)
    print(df5[0])  # Heating
    print(df5[1])  # Cooling
    print(df5[2])  # Summary
    df55 = pd.concat([df5[0], df5[1], df5[2]], axis=0, ignore_index=True)
    #df55.to_excel('LegH_heat_utility_table_combined.xlsx',index=True)
    
    # %%
    print("\nPower Utilities:")
    df6 = bst.report.power_utility_table(LegH_sys.units)
    print(df6)
    #df6.to_excel('LegH_power_utility_table.xlsx',index=True)
    
    # %%
    print("\nOther Utilities:")
    df7 = bst.report.other_utilities_table(LegH_sys.units)
    print(df7)
    #df7.to_excel('LegH_other_utility_table.xlsx',index=True)
    
    print(f"\n{'='*85}")
    print("TEA ANALYSIS COMPLETE")
    print(f"{'='*85}")
    print(f"Target Production:   {TARGET_PRODUCTION:.2f} kg/hr")
    print(f"Achieved Production: {products.F_mass:.2f} kg/hr")
    print(f"LegH MPSP:          ${price:.4f}/kg")
    print(f"{'='*85}\n")

# %%



================ FILE: process_settings.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-07-07 14:55:35

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""

import biosteam as bst

__all__ = ('load_process_settings','price','set_GWPCF','set_FECCF','GWP_CFs','FEC_CFs','set_GWPCF_Multi')

# %% Prices

# =============================================================================
# Prices for techno-economic analysis (TEA), all in $/kg (electricity in $/kWh)
# and from ref [1] if not noted
# =============================================================================

price = {
    'H2O': 0.2/1e3,  # $/kg 0.15 to 0.5 /1e3
    'H2SO4': 0.05,  # $/kg 0.027 to 0.129
    'NH3': 0.46,  # $/kg 0.45 to 0.65
    'NH4OH': 0.4, # $/kg 0.3 to 0.5
    'NH3_25wt': 0.46,  # $/kg 0.3 to 0.5
    'NH4SO4': 0.16,  # $/kg 0.15 to 0.45
    'Glucose': 0.42,  # $/kg 0.5 to 0.9
    'MgSO4': 0.175,  # $/kg 0.3 to 0.6
    'NaOH': 0.28,  # $/kg 0.13 to 0.4
    'KH2PO4': 1.31,  # $/kg 1.2 to 2
    'NaH2PO4': 0.73,  # $/kg 0.5 to 0.82
    'Na2HPO4': 0.55,  # $/kg 0.35 to 0.65
    'K2HPO4': 1.7,  # $/kg 1.3 to 2.2
    'FeSO4': 0.055,  # $/kg 0.4 to 0.8
    'NH42HPO4': 0.569,  # $/kg 0.4 to 0.7
    'NaCl': 0.078,  # $/kg 0.1 to 0.25
    'KCl': 0.23,  # $/kg 0.1 to 0.25
    'EDTA': 2.43,  # $/kg 2 to 4
    'K2HPO4': 1.7,  # $/kg 1.3 to 2.2
    'Glycine': 1.75,  # $/kg 1.5 to 2.5
    'TrehaloseDH': 1.5,  # $/kg 15 to 40
    'SodiumAscorbate': 4.35,  # $/kg 5 to 10
    'Glycerol': 0.45,  # $/kg 0.3 to 0.7
    'sugar': 0.45,  # $/kg
    'ElectricitySG': 0.03,  # $/kWh https://www.spgroup.com.sg/our-services/utilities/tariff-information
    'Electricity': 0.065,  # $/kWh 0.035 to 0.25
    # 'Low pressure steam': 0.30626,  # $/kg
    # 'Cooling water': 0,  # $/kg
}
# %%
# =============================================================================
# Characterization factors (CFs) for life cycle analysis (LCA), all from ref [5] if not noted otherwise
# =============================================================================

# Individual characterization factor dictionaries for each impact category
##### 100-year global warming potential (GWP) in kg CO2-eq/kg unless noted otherwise #####
GWP_CFs = {
    'ElectricitySG': (0.55, 0.55), # from ecoinvent 3.11 cutoff, electricity 0.543 to 0.553
    'Electricity': (0.55, 0.55), # from ecoinvent 3.11 cutoff, electricity, GLO
    'Glucose': 1.61, # from ecoinvent 3.11 cutoff, market for glucose, GLO
    'SulfuricAcid': 0.165, # from ecoinvent 3.11 cutoff, market for sulfuric acid, RoW
    'Sugar_Cane': 0.835, # from ecoinvent 3.11 cutoff, market for sugar, GLO
    'Sugar_Beet': 0.564, # from ecoinvent 3.11 cutoff, market for sugar, GLO
    'IronSulfate': 0.278, # from ecoinvent 3.11 cutoff, market for iron sulfate , RoW
    'MagnesiumSulfate': 0.884, # from ecoinvent 3.11 cutoff, market for magnesium sulfate, GLO
    'Ammonia_SEA': 2.84, # from ecoinvent 3.11 cutoff, market for ammonia, SEA
    'Ammonia_CN': 5.07, # from ecoinvent 3.11 cutoff, market for ammonia, CN
    'Ammonia_US': 2.70, # from ecoinvent 3.11 cutoff, market for ammonia, US
    'AmmoniumSulfate': 0.857, # from ecoinvent 3.11 cutoff, market for ammonium sulfate, RoW
    'Glycine': 5.55, # from ecoinvent 3.11 cutoff, market for glycine, GLO
    'NaCl': 0.268, # from ecoinvent 3.11 cutoff, market for sodium chloride powder, GLO
    'Na2HPO4': 2.29, # from ecoinvent 3.11 cutoff, market for disodium phosphate, GLO
    'NaH2PO4': 2.85, # from ecoinvent 3.11 cutoff, market for monosodium phosphate, RoW
    'K2HPO4': 2.29, # Assumed same as Na2HPO4
    'KH2PO4': 2.85, # Assumed same as NaH2PO4
    'KCl': 0.494, # from ecoinvent 3.11 cutoff, market for potassium chloride, RoW
    'NaOH': 1.41, # from ecoinvent 3.11 cutoff, market for sodium hydroxide, Row
    'CO2': 1.0,  # Direct CO2 emissions
}

# ##### Fossil energy consumption (FEC), in MJ/kg of material unless noted otherwise #####
# FEC_CFs = {
#     'Electricity': (5.926, 5.926), # assume production==consumption, both in MJ/kWh
#     'H2SO4': 568.98/1e3,
#     'NaOH': 29,
#     'NH4OH': 42 * 0.4860, # chemicals.NH3.MW/chemicals.NH4OH.MW,
#     'NH3_25wt': 42 * 0.25,
#     'CH4': 55.5,  # Natural gas FEC (placeholder - update with actual value)
#     # Add more chemicals as needed
# }

# # Consolidated CFs dictionary in the format expected by BioSTEAM LCA module
# # Format: {<impact_category>: {<chemical_ID_or_stream_name>: <CF_value>}}
# CFs = {
#     'GWP_100': {
#         # Extract single values from tuples for electricity, use first value
#         'Electricity': GWP_CFs['Electricity'][0] if isinstance(GWP_CFs['Electricity'], tuple) else GWP_CFs['Electricity'],
#         # Add all other GWP characterization factors
#         **{k: v for k, v in GWP_CFs.items() if k != 'Electricity'},
#         # Placeholder for complex feeds (feedstock streams) - to be updated per biorefinery
#         # 'Glucose': 0.0,  # kg CO2-eq per kg wet feedstock (uncomment and update as needed)
#         # 'Corn': 0.0,     # kg CO2-eq per kg wet feedstock (uncomment and update as needed)
#     },
#     'FEC': {
#         # Extract single values from tuples for electricity
#         'Electricity': FEC_CFs['Electricity'][0] if isinstance(FEC_CFs['Electricity'], tuple) else FEC_CFs['Electricity'],
#         # Add all other FEC characterization factors
#         **{k: v for k, v in FEC_CFs.items() if k != 'Electricity'},
#         # Placeholder for complex feeds (feedstock streams) - to be updated per biorefinery
#         # 'Glucose': 0.0,  # MJ per kg wet feedstock (uncomment and update as needed)
#         # 'Corn': 0.0,     # MJ per kg wet feedstock (uncomment and update as needed)
#     },
# }


# %% Process settings
def set_GWPCF(obj, name='', dilution=None):
    if not dilution: obj.characterization_factors['GWP'] = GWP_CFs[name]
    else: obj.characterization_factors['GWP'] = GWP_CFs[name] * dilution

def set_FECCF(obj, name='', dilution=None):
    if not dilution: obj.characterization_factors['FEC'] = FEC_CFs[name]
    else: obj.characterization_factors['FEC'] = FEC_CFs[name] * dilution

def set_GWPCF_Multi(obj, names=[], dilutions=None):
    """
    Set GWP characterization factors from multiple sources.
    
    Args:
        obj: Object to set characterization factors for
        names: List of names corresponding to GWP_CFs keys
        dilutions: List of dilution factors (same length as names) or single value for all
    """
    if not names:
        return
    
    if dilutions is None:
        # No dilution, just sum the CFs
        total_cf = sum(GWP_CFs[name] for name in names)
    elif isinstance(dilutions, (int, float)):
        # Single dilution value for all
        total_cf = sum(GWP_CFs[name] * dilutions for name in names)
    else:
        # List of dilutions - this handles array input
        if len(dilutions) != len(names):
            raise ValueError("Length of dilutions must match length of names")
        total_cf = sum(GWP_CFs[name] * dil for name, dil in zip(names, dilutions))
    
    obj.characterization_factors['GWP'] = total_cf

def load_process_settings():
    settings = bst.settings
    bst.process_tools.default_utilities()
    settings.CEPCI = 798.8 # 2024
    # Table 17.1 Cost Sheet Outlinea Seider et al. 5th edition
    # settings.electricity_price = 0.07
    hps = settings.get_heating_agent("high_pressure_steam")
    hps.heat_transfer_efficiency = 0.85
    hps.regeneration_price = 17.6/1e3/18.01528#0.08064
    hps.T = 529.2
    hps.P = 44e5
    mps = settings.get_heating_agent("medium_pressure_steam")
    mps.heat_transfer_efficiency = 0.90
    mps.regeneration_price = 15.3/1e3/18.01528#0.07974
    mps.T = 480.3
    mps.P = 18e5
    lps = settings.get_heating_agent("low_pressure_steam")
    lps.heat_transfer_efficiency = 0.95
    lps.regeneration_price = 13.2/1e3/18.01528 #0.06768
    lps.T = 428.6
    lps.P = 55e4

    cw = settings.get_cooling_agent('cooling_water')
    cw.T = 28 + 273.15
    cw.T_limit = cw.T + 9
    cw.regeneration_price = 0.027/1e3/18.01528 #assuming 0.027 $/m3 to $/kmol
    settings.get_cooling_agent('chilled_water').heat_transfer_price = 5.0/1e6 # 5 $/GJ
    settings.electricity_price = 0.065 
    bst.PowerUtility.price = price['ElectricitySG']
    set_GWPCF(bst.PowerUtility, 'ElectricitySG')
    #set_FECCF(bst.PowerUtility, 'Electricity')
    bst.settings.define_impact_indicator(key='GWP', units='kg*CO2e')


================ FILE: units.py ================

# -*- coding: utf-8 -*-
"""
Created on 2025-04-18 15:20:45

@author: Dr. Ouwen Peng
@title: Postdoctoral Researcher
@institute: Illinois ARCS
@email: ouwen.peng@iarcs-create.edu.sg
"""
# %%
import biosteam as bst
from matplotlib.pyplot import cool
import thermosteam as tmo
import numpy as np

from biosteam.units.decorators import cost, copy_algorithm
from biosteam.units.design_tools import CEPCI_by_year, cylinder_diameter_from_volume, cylinder_area
from biosteam import tank_factory
from thermosteam import MultiStream
from biosteam.units.decorators import cost
from biosteam.units.design_tools import size_batch
import biosteam as bst
import numpy as np
import flexsolve as flx

__all__ = (
    ##### Upstream #####    
    # Feedstock Preparation
    #'PretreatmentReactorSystem',

    ## glucose as beginning

    # Bioreactor Fermentaion
    'SeedTrain',
    'AeratedFermentation',

    ##### Downstream #####
    'CellDisruption',
    'ProteinCentrifuge',
    'Evaporator',
    'DiaFiltration',
    'IonExchange',
    'NanofiltrationDF',
    'SprayDrying',
)
Rxn = tmo.reaction.Reaction
ParallelRxn = tmo.reaction.ParallelReaction

# %% Constants
_gal2m3 = 0.003785
_gpm2m3hr = 0.227124
# _m3hr2gpm = 4.40287
_hp2kW = 0.7457
_Gcal2kJ = 4184e3

# %% 
####################
##### UpStream #####
####################

@cost('Flow rate', 'Pumps',
    S=43149, CE=522, cost=24800, n=0.8, kW=40, BM=2.3)
@cost('Stage #1 reactor volume', 'Stage #1 reactors',
    cost=37700, S=20*_gal2m3, CE=522, n=0.7, BM=1.8)
@cost('Stage #2 reactor volume', 'Stage #2 reactors',
    cost=58300, S=200*_gal2m3, CE=522, n=0.7, BM=1.8)
@cost('Stage #3 reactor volume', 'Stage #3 reactors',
    cost=78800, S=2e3*_gal2m3, CE=522, n=0.7, BM=1.8)
@cost('Stage #4 reactor volume', 'Stage #4 reactors',
    cost=176e3, S=20e3*_gal2m3, CE=522, n=0.7, BM=1.8)
@cost('Stage #4 reactor volume', 'Stage #4 agitators',
    cost=26e3/2, S=20e3*_gal2m3, kW=7.5, CE=522, n=0.5, BM=1.5)
@cost('Stage #5 reactor volume', 'Stage #5 reactors',
    cost=590e3, S=200e3*_gal2m3, CE=522, n=0.7, BM=1.8)
@cost('Stage #5 reactor volume', 'Stage #5 agitators',
    cost=43e3/2, S=200e3*_gal2m3, kW=10, CE=522, n=0.5, BM=1.5)
class SeedTrain(bst.Unit):
    _N_ins = 1
    _N_outs = 2
    _ins_size_is_fixed = False
    
    _units= {'Flow rate': 'kg/hr',
            'Stage #1 reactor volume': 'm3',
            'Stage #2 reactor volume': 'm3',
            'Stage #3 reactor volume': 'm3',
            'Stage #4 reactor volume': 'm3',
            'Stage #5 reactor volume': 'm3'}
    
    @property
    def N_stages(self): 
        """Number of stages in series."""
        return 5
    
    #: Number of parallel seed trains
    N_trains = 2
    
    #: Cycle time for each batch (hr)
    tau_batch = 16
    
    @property
    def tau_turnover(self):
        """Turnover time (hr) calculated by batch time divided by number of trains."""
        return self.tau_batch/self.N_trains
    
    #: Operating temperature (K)
    T = 32+273.15
    
    # #: Diammonium phosphate loading in g/L of fermentation broth
    # DAP = 0.67 
    
    def _init(self, reactions=None, saccharification=None, T=None):
        chemicals = self.chemicals

        if reactions is None:
            self.reactions = ParallelRxn([
        #   Reaction definition                             Reactant    Conversion
        Rxn('Glucose -> 2 Ethanol + 2 CO2',                 'Glucose',   0.9000, chemicals),
        Rxn('Glucose + 0.047 CSL + 0.018 DAP -> 6 Z_mobilis + 2.4 H2O',
                                                            'Glucose',   0.0400, chemicals),
        Rxn('Glucose + 2 H2O -> 2 Glycerol + O2',           'Glucose',   0.0040, chemicals),
        Rxn('Glucose + 2 CO2 -> 2 SuccinicAcid + O2',       'Glucose',   0.0060, chemicals),
        # Rxn('3 Xylose -> 5 Ethanol + 5 CO2',                'Xylose',    0.8000, chemicals),
        # Rxn('Xylose + 0.039 CSL + 0.015 DAP -> 5 Z_mobilis + 2 H2O',
        #                                                     'Xylose',    0.0400, chemicals),
        # Rxn('3 Xylose + 5 H2O -> 5 Glycerol + 2.5 O2',      'Xylose',    0.0030, chemicals),
        # Rxn('Xylose + H2O -> Xylitol + 0.5 O2',             'Xylose',    0.0460, chemicals),
        # Rxn('3 Xylose + 5 CO2 -> 5 SuccinicAcid + 2.5 O2',  'Xylose',    0.0090, chemicals)
            ])
            self.glucose_to_ethanol = self.reactions[0]
            # self.xylose_to_ethanol = self.reactions[4]
            self.glucose_to_byproducts = self.reactions[1:4]
            # self.xylose_to_byproducts = self.reactions[5:]
        else:
            self.reactions = reactions
        
        if callable(saccharification):
            self.saccharification = saccharification
        elif saccharification:
            self.saccharification = ParallelRxn([
                Rxn('Glucan -> GlucoseOligomer',          'Glucan',   0.0400, chemicals),
                Rxn('Glucan + 0.5 H2O -> 0.5 Cellobiose', 'Glucan',   0.0120, chemicals),
                Rxn('Glucan + H2O -> Glucose',            'Glucan',   0.9000, chemicals),
                Rxn('Cellobiose + H2O -> 2Glucose',       'Cellobiose',  1.0000, chemicals)]
            )
        else:
            self.saccharification = None
        if T: self.T = T
    
    _setup = bst.Unit._setup
    
    def _run(self):
        vent, effluent= self.outs
        effluent.mix_from(self.ins, energy_balance=False)
        if self.saccharification:
            self.saccharification(effluent)
        self.reactions.force_reaction(effluent)
        effluent.empty_negative_flows()
        effluent.T = self.T
        vent.phase = 'g'
        vent.copy_flow(effluent, ('CO2', 'O2'), remove=True)

    def _design(self): 
        maxvol = self.outs[1].F_vol*self.tau_turnover
        vol = maxvol*10**-self.N_stages
        Design = self.design_results
        for i in range(1, self.N_stages+1):
            Design[f'Stage #{i} reactor volume'] = vol
            vol *= 10 
        Design['Flow rate'] = sum([i.F_mass for i in self.outs])
        self.add_heat_utility(self.Hnet, self.T)

    def _cost(self):
        pass
        N = self.N_trains
        D = self.design_results
        C = self.baseline_purchase_costs
        kW = 0
        for i, x in self.cost_items.items():
            S = D[x._basis]
            q = S/x.S
            C[i] = N*bst.CE/x.CE*x.cost*q**x.n
            kW += N*x.kW*q
        self.power_utility(kW)

class AeratedFermentation(bst.AeratedBioreactor):
    # V_max_default = 500
    def _init(
            self, 
            fermentation_reaction, 
            cell_growth_reaction, 
            respiration_reaction,
            neutralization_reaction,
            dT_hx_loop=8,
            Q_O2_consumption=-460240, # [kJ/kmol] equivalent to 110 kcal / mol as in https://www.academia.edu/19636928/Bioreactor_Design_for_Chemical_Engineers
            batch=True,
            **kwargs,
        ):
        bst.AeratedBioreactor._init(self, batch=batch, dT_hx_loop=dT_hx_loop, 
                                    Q_O2_consumption=Q_O2_consumption,
                                    optimize_power=True, **kwargs)
        chemicals = self.chemicals
        # self.hydrolysis_reaction = Rxn('Sucrose + Water -> 2Glucose', 'Sucrose', 1.00, chemicals)
        self.V_max_default = 500
        self.fermentation_reaction = fermentation_reaction
        self.cell_growth_reaction = cell_growth_reaction
        self.respiration_reaction = respiration_reaction
        self.neutralization_reaction = neutralization_reaction

    def _run_vent(self, vent, effluent):
        vent.copy_flow(effluent, ('CO2', 'O2', 'N2'), remove=True)
        assert not effluent.imol['CO2', 'O2', 'N2'].any()
    
    def _run_reactions(self, effluent):
        # self.hydrolysis_reaction.force_reaction(effluent)
        # self.lipid_reaction.force_reaction(effluent)
        
        # Ensure water doesn't go negative
        if effluent.imol['H2O'] < 0.: 
            effluent.imol['H2O'] = 0.
        
        # Check if we have sufficient reactants before running reactions
        glucose_available = effluent.imol['Glucose']
        if glucose_available < 1e-6:  # Very small amount of glucose
            return
            
        # Store initial state to prevent excessive consumption
        initial_glucose = effluent.imol['Glucose']
        initial_O2 = effluent.imol['O2']
        
        self.fermentation_reaction.force_reaction(effluent)
        self.cell_growth_reaction.force_reaction(effluent)
        self.respiration_reaction.force_reaction(effluent)
        self.neutralization_reaction.force_reaction(effluent)
        
        # # Ensure no negative flows after reactions
        # for chemical in effluent.chemicals:
        #     if effluent.imol[chemical.ID] < 0:
        #         effluent.imol[chemical.ID] = 0
                
        # # Ensure minimum oxygen consumption for aeration calculation
        # # If oxygen is being produced instead of consumed, set a minimum consumption
        # O2_change = effluent.imol['O2'] - initial_O2
        # if O2_change >= 0:  # Oxygen is being produced or unchanged
        #     # Set a minimum oxygen consumption to ensure proper aeration
        #     min_O2_consumption = initial_glucose * 0.1  # 10% of glucose as minimum O2 consumption
        #     effluent.imol['O2'] = max(0, initial_O2 - min_O2_consumption)


class PSA(bst.Flash): 
    _units= {'Liquid flow': 'kg/hr'}
    
    def _run(self):
        influent = self.ins[0]
        vapor, liquid = self.outs
        
        ms = tmo.MultiStream('ms')
        ms.copy_like(influent)
        ms.vle(P=101325, H=ms.H)
        
        vapor.mol = ms.imol['g']
        vapor.phase = 'g'
        liquid.mol = ms.imol['l']
        vapor.T = liquid.T = ms.T
        vapor.P = liquid.P = ms.P
        
    def _design(self):
        self.design_results['Liquid flow'] = self.outs[1].F_mass

# %%
######################
##### Downstream #####
######################


# https://www.alibaba.com/product-detail/1000L-2000L-SUS-High-Shear-Maquina_1601244807309.html?spm=a2700.galleryofferlist.topad_classic.d_title.358b13a0lSlmVy&priceId=fa9c440338e5471698929aa241dc50fa
# 1000L 7000 USD single price
class CellDisruption(bst.Unit):
    """
    Cell disruption unit using high-pressure homogenization.
    Converts biomass into its constituent components using a manual mass balance.
    Models both power consumption and thermal effects of pressure drop.
    """
    _N_ins = 1
    _N_outs = 1
    _graphics = bst.Pump._graphics
    
    _F_BM_default = {
        'High-Pressure Homogenizer': 3.5, 
    }

    def __init__(self, ID='', ins=None, outs=(),
                 Cell_ID='Pichia_pastoris', 
                 cell_disruption_efficiency=0.55, # 50~60% typical as soluble ,others are debris
                 component_fractions=None,
                 P_high=150e5, P_low=101325):
        super().__init__(ID, ins, outs)
        
        self.cell_disruption_efficiency = cell_disruption_efficiency
        self.P_high = P_high
        self.P_low = P_low
        self.Cell_ID= Cell_ID
        
        if component_fractions is None:
            self.component_fractions = {
                'Mannoprotein': 0.40, 'Glucan': 0.50, 'OleicAcid': 0.06,
                'Chitin': 0.03, 'RNA': 0.01,
                # 'Mannoprotein': 0.40, 'Glucan': 0.50/6, 'OleicAcid': 0.06/18,
                # 'Chitin': 0.03/8, 'RNA': 0.01/4,
            }
        else:
            self.component_fractions = component_fractions
        
        total_fraction = sum(self.component_fractions.values())
        if not np.isclose(total_fraction, 1.0):
            raise ValueError(f"Component fractions must sum to 1.0, but they sum to {total_fraction}.")
            
    def _run(self):
        """Simulate the mass balance of the disruption."""
        feed = self.ins[0]
        outlet = self.outs[0]
        outlet.copy_like(feed)
        
        disrupted_mass = feed.imass[self.Cell_ID] * self.cell_disruption_efficiency
        
        outlet.imass[self.Cell_ID] -= disrupted_mass
        
        for component, fraction in self.component_fractions.items():
            outlet.imass[component] += fraction * disrupted_mass


        # Convert intracellular molecules to extracellular form based on disruption efficiency
        for chem in self.chemicals:
            chem_id = chem.ID
            if chem_id.endswith('_In'):
                # Get the extracellular molecule name by removing '_In' suffix
                extracellular_id = chem_id[:-3]
                if extracellular_id in self.chemicals:
                    # Calculate mass released from disrupted cells
                    intracellular_mass = feed.imass[chem_id]
                    released_mass = intracellular_mass * self.cell_disruption_efficiency
                    
                    # Transfer released mass to extracellular form
                    outlet.imass[extracellular_id] += released_mass
                    # Remaining intracellular mass stays in undisrupted cells
                    outlet.imass[chem_id] = intracellular_mass - released_mass
                    
        
        # The final temperature will be determined by the valve simulation in _design
        # For now, we set pressure and leave temperature as is.
        pumpout = bst.Stream('')
        pumpout.copy_like(outlet)
        pumpout.P = self.P_high
        temp_valve = bst.IsenthalpicValve(
            ID='valve',
            ins=pumpout,
            P=self.P_low, 
            vle=False,
        )
        temp_valve.simulate()
        outlet.copy_like(temp_valve.outs[0])

        # outlet.P= self.P_low

    
    def _design(self):
        """Design the homogenizer, calculating power and thermal effects."""
        feed = self.ins[0]
        
        # --- Create temporary, local unit operations for calculation ---
        # This is the key: they are not attached to `self`.
        
        # 1. Multi-stage pump system to achieve high pressure
        # Calculate number of stages needed (typical compression ratio ~3-5 per stage)
        compression_ratio_per_stage = 4.0
        n_stages = max(1, int(np.ceil(np.log(self.P_high / feed.P) / np.log(compression_ratio_per_stage))))
        
        # Create pressure stages
        pressure_stages = [feed.P * (compression_ratio_per_stage ** i) for i in range(1, n_stages + 1)]
        pressure_stages[-1] = self.P_high  # Ensure final pressure is exact
        
        # Create and simulate multi-stage pumps
        total_power = 0
        current_stream = feed.copy()
        
        for target_pressure in pressure_stages:
            temp_pump = bst.Pump(
            ins=current_stream.copy(),
            P=target_pressure
            )
            temp_pump.simulate()
            total_power += temp_pump.power_utility.rate
            current_stream = temp_pump.outs[0].copy()
        
        # Store total power consumption
        self.power_utility.rate = total_power
        
        # 2. Simulate the valve to find the thermal effect (e.g., cooling)
        temp_valve = bst.IsenthalpicValve(
            ID=f'_{self.ID}_valve',
            ins=temp_pump.outs[0],
            P=self.P_low, 
            vle=False,
        )
        temp_valve.simulate()

        # --- Capture the results for the main CellDisruption unit ---
        #self.power_utility.rate = temp_pump.power_utility.rate
        self.heat_utilities = temp_valve.heat_utilities
        
        # # Update the outlet stream's temperature to the final calculated temperature
        # self.outs[0].T = temp_valve.outs[0].T
        
        # # --- Costing based on the calculated power ---
        # power_kW = self.power_utility.rate
        # Inguva, P., Grasselli, S. & Heng, P. W. S. High pressure homogenization – 
        # An update on its usage and understanding. Chemical Engineering Research and Design 202, 284–302 (2024).
        dP = (self.P_high - self.P_low)/1e5
        power_kW = (feed.F_vol * 1000) * dP / (36000 * 0.85)  # Assuming 85% efficiency
        #self.power_utility.rate = power_kW

        # purchase_cost = 20000 * (power_kW / 10)**0.64 if power_kW > 0 else 0
        purchase_cost = 90000 * (feed.F_vol*1000)**0.5 * (dP/1000)**1.5

        self.design_results['Power (kW)'] = power_kW
        self.design_results['Purchase cost (USD)'] = purchase_cost
        
    def _cost(self):
        """Cost the homogenizer."""
        self.baseline_purchase_costs['High-Pressure Homogenizer'] = self.design_results['Purchase cost (USD)']


class Centrifuge(bst.SolidsCentrifuge):pass

class ReverseOsmosis(bst.Unit):
    """
    Create a reverse osmosis unit operation for recovering water from brine.
    The model is based on a fraction of water recovered.
    
    Parameters
    ----------
    ins : 
        Inlet fluid to be split.
    outs : 
        * [0] Filtered water
        * [1] Brine
    water_recovery : float, optional
        Water recovered to 0th stream. Defaults to 0.987
    
    """
    _N_ins = 1
    _N_outs = 2
    
    _F_BM_default = {
        'Pump': 2.3,
        'Membrane replacement': 1.65,
        'Hardware': 2.0,
    }

    _units = {
        'Flow rate': 'm3/hr',
        'Power': 'kW',
        'Pump Pressure': 'bar',
        'Water recovery': '%',
        'Membrane Area': 'm2',
        'Membrane flux': 'L/m2/hr',
        'Membrane lifetime': 'years',
        'Plant lifetime': 'years',
        'Membrane cost per m2': 'USD/m2',
    }

    def _init(self, water_recovery=0.987, membrane_flux=40, membrane_cost_per_m2=300, 
                membrane_lifetime_years=3, plant_lifetime_years=20, operating_pressure_bar=30):
        self.water_recovery = water_recovery
        self.membrane_flux = membrane_flux  # L/m2/hr
        self.membrane_cost_per_m2 = membrane_cost_per_m2  # USD/m2
        self.membrane_lifetime_years = membrane_lifetime_years
        self.plant_lifetime_years = plant_lifetime_years
        self.operating_pressure_bar = operating_pressure_bar
    
    @property
    def RO_treated_water(self):
        return self.outs[0]
    
    def _run(self):
        feed, = self.ins
        water, brine = self.outs
        water.copy_thermal_condition(feed)
        brine.copy_like(feed)
        water_index = self.chemicals.index('H2O')
        water_flow = brine.mol[water_index]
        water_recovered = self.water_recovery * water_flow
        water.mol[water_index] = water_recovered
        brine.mol[water_index] = water_flow - water_recovered

    def _design(self):
        Design = self.design_results
        feed = bst.Stream()
        feed.copy_like(self.ins[0])
        
        # Record basic operating parameters
        Design['Flow rate'] = feed.F_vol  # m3/hr
        Design['Water recovery'] = self.water_recovery * 100  # %
        Design['Pump Pressure'] = self.operating_pressure_bar  # bar
        Design['Membrane flux'] = self.membrane_flux  # L/m2/hr
        Design['Membrane lifetime'] = self.membrane_lifetime_years  # years
        Design['Plant lifetime'] = self.plant_lifetime_years  # years
        Design['Membrane cost per m2'] = self.membrane_cost_per_m2  # USD/m2

        # Calculate membrane area based on flux and flow rate
        flow_rate_L_hr = feed.F_vol * 1000  # convert m3/hr to L/hr
        #flow_rate_L_hr = feed.ivol['H2O'] * 1000  # convert m3/hr to L/hr
        if self.membrane_flux > 0:
            membrane_area_m2 = flow_rate_L_hr / self.membrane_flux
        else:
            membrane_area_m2 = 0.0
        Design['Membrane Area'] = membrane_area_m2  # m2

        # Create temporary pump for power calculation
        self.pump = bst.Pump(
            ins=feed,
            outs=(),
            P=self.operating_pressure_bar * 1e5  # Convert bar to Pa
        )
        self.pump.simulate()
        self.pump._design()
        
        # Record power consumption
        power_kW = self.pump.power_utility.rate
        Design['Power'] = power_kW  # kW
        self.power_utility.rate = power_kW

    def _cost(self):
        C = self.baseline_purchase_costs
        D = self.design_results
        
        # Cost the pump
        if hasattr(self, 'pump') and self.pump:
            self.pump._cost()
            C['Pump'] = self.pump.purchase_cost
        else:
            C['Pump'] = 0.0
        
        # Cost membrane replacement based on membrane area
        membrane_area = D.get('Membrane Area', 0.0)
        if membrane_area > 0 and self.membrane_lifetime_years > 0:
            # Calculate total membrane replacement cost over plant lifetime
            num_replacements = self.plant_lifetime_years / self.membrane_lifetime_years
            total_membrane_cost = membrane_area * self.membrane_cost_per_m2 * num_replacements
            C['Membrane replacement'] = total_membrane_cost
        else:
            C['Membrane replacement'] = 0.0
        
        # Cost other hardware based on flow rate
        feed_flow_rate = D.get('Flow rate', 0.0)  # m3/hr


class Diafiltration(bst.Unit):
    """
    Diafiltration unit for separation of solutes based on size, typically
    retaining larger molecules (like proteins) while allowing smaller ones
    (like salts and water) to pass through the permeate. Includes continuous
    addition of wash solution (diafiltration buffer).

    (Docstrings for parameters remain the same as your original code)
    """
    _N_ins = 2
    _N_outs = 2
    
    # --- All default values, _F_BM_default, and _units remain the same ---
    _F_BM_default = {
        'Membrane System': 1.65,
        'Membrane replacement': 1.65,#1.0,
        'Pump': 1.89,
    }
    water_ID = 'H2O'
    _default_TargetProduct_ID = 'TargetProduct'
    _default_Salt_ID = 'Salt'
    _default_OtherLargeMolecules_ID = 'OtherLargeMolecules'
    _default_TargetProduct_Retention = 0.98
    _default_Salt_Retention = 0.05
    _default_OtherLargeMolecules_Retention = 0.98
    _default_DefaultSolutes_Retention = 0.08
    _default_FeedWater_Recovery_to_Permeate = 0.75
    _default_membrane_flux_LMH = 40.0 # ultra: 20~80, nano: 10~40
    _default_TMP_bar1 = 2.0 # ultra: 2~4, nano: 10 ~25
    _default_TMP_bar2 = 2.0 # ultra: 1.5~3, nano: 3~6
    _default_membrane_cost_USD_per_m2 = 150.0
    # Industry	Membrane Type	Approximate Value Range (USD/m²)
    # Food & Beverage	Ultrafiltration	$100 - $400
    #                   Nanofiltration	$150 - $500
    # Pharmaceutical	Ultrafiltration	$1,200 - $3,500+
    #                   Nanofiltration	$2,000 - $5,000+
    # https://www.biopharminternational.com/view/economic-analysis-single-use-tangential-flow-filtration-biopharmaceutical-applications


    # food ultra: 50-250, nano: 70~300
    # for pharm: ultra: 1500~3000, nano: 2500~4500
    # Membrane Type	Industrial / Water	Food & Beverage	Biopharmaceutical (TFF Cassettes)
    # Ultrafiltration (UF)	$80 - $350	$250 - $900	$1,500 - $5,000+
    # Nanofiltration (NF)	$100 - $400	$300 - $1,200	$2,000 - $7,000+
    _default_membrane_lifetime_years = 2.0 #1~3
    _default_module_cost_factor = 25000.0
    _default_module_cost_exponent = 0.7
    _default_base_CEPCI = 500.0
    _default_reciculation_ratio = 10.0  # Recirculation ratio to reduce fouling 5~20
    _default_equipment_lifetime_years = 20.0  # Typical equipment lifetime for CAPEX calculation
    _units = {
        'Membrane Area': 'm2',
        'TargetProduct_Retention': '%',
        'Salt_Retention': '%',
        'OtherLargeMolecules_Retention': '%',
        'DefaultSolutes_Retention': '%',
        'FeedWater_Recovery_to_Permeate': '%',
        'membrane_flux_LMH': 'LMH',
        'TMP_bar1': 'bar',
        'TMP_bar2': 'bar',
        'pump_efficiency': '%',
        'membrane_cost_USD_per_m2': '$/m2',
        'membrane_lifetime_years': 'years',
        'equipment_lifetime_years': 'years',
        'module_cost_factor': '$/m2^exponent',
        'module_cost_exponent': '0.6',
        'base_CEPCI': '500',
    }
    
    def __init__(self, ID='', ins=None, outs=None, thermo=None,
                 TargetProduct_ID=None, Salt_ID=None, OtherLargeMolecules_ID=None,
                 TargetProduct_Retention=None, Salt_Retention=None,
                 OtherLargeMolecules_Retention=None, DefaultSolutes_Retention=None,
                 FeedWater_Recovery_to_Permeate=None,
                 membrane_flux_LMH=None, TMP_bar1=None, TMP_bar2=None,
                 membrane_cost_USD_per_m2=None, membrane_lifetime_years=None,
                 equipment_lifetime_years=None,
                 module_cost_factor=None, module_cost_exponent=None, base_CEPCI=None,
                 reciculation_ratio=None,
                 **kwargs):
        super().__init__(ID, ins, outs, thermo)
        # --- All __init__ logic remains the same ---
        self.TargetProduct_ID = TargetProduct_ID if TargetProduct_ID is not None else self._default_TargetProduct_ID
        self.Salt_ID = Salt_ID if Salt_ID is not None else self._default_Salt_ID
        self.OtherLargeMolecules_ID = OtherLargeMolecules_ID if OtherLargeMolecules_ID is not None else self._default_OtherLargeMolecules_ID
        self.TargetProduct_Retention = TargetProduct_Retention if TargetProduct_Retention is not None else self._default_TargetProduct_Retention
        self.Salt_Retention = Salt_Retention if Salt_Retention is not None else self._default_Salt_Retention
        self.OtherLargeMolecules_Retention = OtherLargeMolecules_Retention if OtherLargeMolecules_Retention is not None else self._default_OtherLargeMolecules_Retention
        self.DefaultSolutes_Retention = DefaultSolutes_Retention if DefaultSolutes_Retention is not None else self._default_DefaultSolutes_Retention
        self.FeedWater_Recovery_to_Permeate = FeedWater_Recovery_to_Permeate if FeedWater_Recovery_to_Permeate is not None else self._default_FeedWater_Recovery_to_Permeate
        self.membrane_flux_LMH = membrane_flux_LMH if membrane_flux_LMH is not None else self._default_membrane_flux_LMH
        self.TMP_bar1 = TMP_bar1 if TMP_bar1 is not None else self._default_TMP_bar1
        self.TMP_bar2 = TMP_bar2 if TMP_bar2 is not None else self._default_TMP_bar2
        self.membrane_cost_USD_per_m2 = membrane_cost_USD_per_m2 if membrane_cost_USD_per_m2 is not None else self._default_membrane_cost_USD_per_m2
        self.membrane_lifetime_years = membrane_lifetime_years if membrane_lifetime_years is not None else self._default_membrane_lifetime_years
        self.equipment_lifetime_years = equipment_lifetime_years if equipment_lifetime_years is not None else self._default_equipment_lifetime_years
        self.module_cost_factor = module_cost_factor if module_cost_factor is not None else self._default_module_cost_factor
        self.module_cost_exponent = module_cost_exponent if module_cost_exponent is not None else self._default_module_cost_exponent
        self.base_CEPCI = base_CEPCI if base_CEPCI is not None else self._default_base_CEPCI
        self.reciculation_ratio = reciculation_ratio if reciculation_ratio is not None else self._default_reciculation_ratio
        self.power_utility = bst.PowerUtility()

    def _run(self):
        feed, wash_solution = self.ins
        retentate, permeate = self.outs
        
        _mixed_stream = bst.Stream()
        _mixed_stream.mol = feed.mol + wash_solution.mol
        _mixed_stream.H = feed.H + wash_solution.H
        
        # Assign the correct temperature and pressure
        retentate.T = permeate.T = _mixed_stream.T
        retentate.P = permeate.P = _mixed_stream.P
        # retentate.T = permeate.T = feed.T
        # retentate.P = permeate.P = feed.P

        permeate.empty()
        retentate.empty() # Start with empty streams for clarity

        # --- Water Balance (Unchanged) ---
        feed_water_mass = feed.imass[self.water_ID]
        wash_water_mass = wash_solution.imass[self.water_ID]
        total_incoming_water = feed_water_mass + wash_water_mass

        retentate_water_from_feed = feed_water_mass * (1.0 - self.FeedWater_Recovery_to_Permeate)
        retentate.imass[self.water_ID] = max(0.0, retentate_water_from_feed)
        
        permeate.imass[self.water_ID] = total_incoming_water - retentate.imass[self.water_ID]
        if permeate.imass[self.water_ID] < 0:
            permeate.imass[self.water_ID] = 0.0
            retentate.imass[self.water_ID] = total_incoming_water

        # --- Solute Balance ---
        # Build a retention map from configured IDs. Accept str, list, tuple, or set.
        # Normalize inputs and validate against available chemical IDs.
        retention_map = {}

        # Helper to normalize IDs to a flat list
        def _to_id_list(x):
            if x is None:
                return []
            if isinstance(x, (list, tuple, set)):
                return [i for i in x if i is not None]
            return [x]

        target_ids = _to_id_list(self.TargetProduct_ID)
        large_mol_ids = _to_id_list(self.OtherLargeMolecules_ID)
        salt_ids = _to_id_list(self.Salt_ID)

        # Use a set of available chemical IDs for robust membership tests
        available_ids = {chem.ID for chem in self.chemicals}

        # Only add to retention_map if the chemical ID exists in thermo chemicals
        # If an ID is not found, skip and optionally warn once per call
        import warnings as _warnings

        def _map_ids(ids, retention, label):
            missing = []
            for chem_id in ids:
                if chem_id in available_ids:
                    retention_map[chem_id] = retention
                else:
                    missing.append(chem_id)
            if missing:
                _warnings.warn(
                    f"Diafiltration: {label} IDs not found in thermo chemicals and will use default retention: {missing}",
                    RuntimeWarning,
                )

        _map_ids(target_ids, self.TargetProduct_Retention, "TargetProduct")
        _map_ids(large_mol_ids, self.OtherLargeMolecules_Retention, "OtherLargeMolecules")
        _map_ids(salt_ids, self.Salt_Retention, "Salt")

        for chem in self.chemicals:
            ID = chem.ID
            if ID == self.water_ID:
                continue

            total_mass_in = feed.imass[ID] + wash_solution.imass[ID]
            if total_mass_in < 1e-12: continue

            current_retention = retention_map.get(ID, self.DefaultSolutes_Retention)

            # ####################################################################
            # POINT OF CHANGE: UNIFIED SOLUTE BALANCE LOGIC
            # ####################################################################
            # The previous if/else logic is removed. All solutes are now handled
            # by this single, more realistic model.
            
            # The mass of any solute in the retentate is its total input mass
            # multiplied by its specific retention factor.
            retentate.imass[ID] = total_mass_in * current_retention
            
            # The mass in the permeate is simply the remainder, ensuring mass balance.
            permeate.imass[ID] = total_mass_in - retentate.imass[ID]
            # ####################################################################
            
            # Final safety check remains the same
            if permeate.imass[ID] < 0:
                retentate.imass[ID] += permeate.imass[ID]
                permeate.imass[ID] = 0.0
            if retentate.imass[ID] < 0:
                permeate.imass[ID] += retentate.imass[ID]
                retentate.imass[ID] = 0.0

    def _design(self):
        # --- No changes to _design method ---
        Design = self.design_results
        permeate_stream = self.outs[1]
        if permeate_stream.isempty() or permeate_stream.rho == 0:
            permeate_vol_L_per_hr = 0.0
        else:
            permeate_vol_L_per_hr = permeate_stream.F_vol *1000 #(permeate_stream.F_mass / permeate_stream.rho) 
        if self.membrane_flux_LMH > 0 and permeate_vol_L_per_hr > 0:
            membrane_area_m2 = permeate_vol_L_per_hr / self.membrane_flux_LMH
        else:
            membrane_area_m2 = 0.0
        Design['Membrane Area'] = membrane_area_m2
        Design['membrane_flux_LMH'] = self.membrane_flux_LMH
        Design['TMP_bar1'] = self.TMP_bar1
        Design['TMP_bar2'] = self.TMP_bar2
        Design['membrane_cost_USD_per_m2'] = self.membrane_cost_USD_per_m2
        Design['membrane_lifetime_years'] = self.membrane_lifetime_years
        Design['equipment_lifetime_years'] = self.equipment_lifetime_years
        internal_stream = self.ins[0].copy() + self.ins[1].copy()
        self.pump1 = bst.Pump(None, None, P=self.TMP_bar1 * 1e5)
        self.pump1.ins[0] = internal_stream
        self.pump1.simulate()
        self.pump1._design()
        self.pump2 = bst.Pump(None, None, P=self.TMP_bar2 * 1e5)
        self.pump2.ins[0] = internal_stream * self.reciculation_ratio 
        self.pump2.simulate()
        self.pump2._design()
        Design['pump1_efficiency'] = 0.85 * 100.0
        Design['pump2_efficiency'] = 0.85 * 100.0
        self.power_utility.rate = self.pump1.power_utility.rate / (Design['pump1_efficiency']/100) + self.pump2.power_utility.rate / (Design['pump2_efficiency']/100)

    def _cost(self):
        # --- MODIFIED: Properly calculate total membrane replacement cost over equipment lifetime ---
        area_m2 = self.design_results.get('Membrane Area', 0.0)
        if area_m2 > 0 and self.module_cost_factor > 0 and self.base_CEPCI > 0:
            base_purchase_cost = self.module_cost_factor * (area_m2 ** self.module_cost_exponent)
            current_purchase_cost = base_purchase_cost * (bst.CE / self.base_CEPCI)
            self.baseline_purchase_costs['Membrane System'] = current_purchase_cost
        else:
            self.baseline_purchase_costs['Membrane System'] = 0.0
            
        # Calculate total membrane replacement cost over equipment lifetime
        if (self.membrane_lifetime_years > 0 and
            self.membrane_cost_USD_per_m2 > 0 and
            area_m2 > 0 and
            self.equipment_lifetime_years > 0):
            
            # Calculate number of membrane replacements over equipment lifetime
            num_replacements = self.equipment_lifetime_years / self.membrane_lifetime_years
            
            # Total membrane replacement cost over equipment lifetime
            total_replacement_cost = num_replacements * area_m2 * self.membrane_cost_USD_per_m2
            
            self.baseline_purchase_costs['Membrane replacement'] = total_replacement_cost
        else:
            self.baseline_purchase_costs['Membrane replacement'] = 0.0
            
        self.baseline_purchase_costs['Pump'] = self.pump1.purchase_cost + self.pump2.purchase_cost # Assume 2 pumps for operation feed & recirculation

class Ultrafiltration(bst.Unit):
    """
    Single-pass ultrafiltration unit with one feed stream.
    Retains the Diafiltration retention logic but removes diafiltration buffer
    and circulation pump handling.
    """
    _N_ins = 1
    _N_outs = 2

    _F_BM_default = {
        'Membrane System': 1.65,
        'Membrane replacement': 1.65,
        'Pump': 1.89,
    }
    water_ID = Diafiltration.water_ID
    _default_TargetProduct_ID = Diafiltration._default_TargetProduct_ID
    _default_Salt_ID = Diafiltration._default_Salt_ID
    _default_OtherLargeMolecules_ID = Diafiltration._default_OtherLargeMolecules_ID
    _default_TargetProduct_Retention = Diafiltration._default_TargetProduct_Retention
    _default_Salt_Retention = Diafiltration._default_Salt_Retention
    _default_OtherLargeMolecules_Retention = Diafiltration._default_OtherLargeMolecules_Retention
    _default_DefaultSolutes_Retention = Diafiltration._default_DefaultSolutes_Retention
    _default_FeedWater_Recovery_to_Permeate = Diafiltration._default_FeedWater_Recovery_to_Permeate
    _default_membrane_flux_LMH = Diafiltration._default_membrane_flux_LMH
    _default_TMP_bar = Diafiltration._default_TMP_bar1
    _default_membrane_cost_USD_per_m2 = Diafiltration._default_membrane_cost_USD_per_m2
    _default_membrane_lifetime_years = Diafiltration._default_membrane_lifetime_years
    _default_module_cost_factor = Diafiltration._default_module_cost_factor
    _default_module_cost_exponent = Diafiltration._default_module_cost_exponent
    _default_base_CEPCI = Diafiltration._default_base_CEPCI
    _default_equipment_lifetime_years = Diafiltration._default_equipment_lifetime_years

    _units = Diafiltration._units

    def __init__(self, ID='', ins=None, outs=None, thermo=None,
                 TargetProduct_ID=None, Salt_ID=None, OtherLargeMolecules_ID=None,
                 TargetProduct_Retention=None, Salt_Retention=None,
                 OtherLargeMolecules_Retention=None, DefaultSolutes_Retention=None,
                 FeedWater_Recovery_to_Permeate=None,
                 membrane_flux_LMH=None, TMP_bar=None,
                 membrane_cost_USD_per_m2=None, membrane_lifetime_years=None,
                 equipment_lifetime_years=None,
                 module_cost_factor=None, module_cost_exponent=None, base_CEPCI=None,
                 **kwargs):
        super().__init__(ID, ins, outs, thermo, **kwargs)
        self.TargetProduct_ID = TargetProduct_ID if TargetProduct_ID is not None else self._default_TargetProduct_ID
        self.Salt_ID = Salt_ID if Salt_ID is not None else self._default_Salt_ID
        self.OtherLargeMolecules_ID = OtherLargeMolecules_ID if OtherLargeMolecules_ID is not None else self._default_OtherLargeMolecules_ID
        self.TargetProduct_Retention = TargetProduct_Retention if TargetProduct_Retention is not None else self._default_TargetProduct_Retention
        #self.Salt_Retention = Salt_Retention if Salt_Retention is not None else self._default_Salt_Retention
        self.OtherLargeMolecules_Retention = OtherLargeMolecules_Retention if OtherLargeMolecules_Retention is not None else self._default_OtherLargeMolecules_Retention
        self.DefaultSolutes_Retention = DefaultSolutes_Retention if DefaultSolutes_Retention is not None else self._default_DefaultSolutes_Retention
        self.FeedWater_Recovery_to_Permeate = FeedWater_Recovery_to_Permeate if FeedWater_Recovery_to_Permeate is not None else self._default_FeedWater_Recovery_to_Permeate
        self.Salt_Retention = 1 - self.FeedWater_Recovery_to_Permeate
        self.membrane_flux_LMH = membrane_flux_LMH if membrane_flux_LMH is not None else self._default_membrane_flux_LMH
        self.TMP_bar = TMP_bar if TMP_bar is not None else self._default_TMP_bar
        self.membrane_cost_USD_per_m2 = membrane_cost_USD_per_m2 if membrane_cost_USD_per_m2 is not None else self._default_membrane_cost_USD_per_m2
        self.membrane_lifetime_years = membrane_lifetime_years if membrane_lifetime_years is not None else self._default_membrane_lifetime_years
        self.equipment_lifetime_years = equipment_lifetime_years if equipment_lifetime_years is not None else self._default_equipment_lifetime_years
        self.module_cost_factor = module_cost_factor if module_cost_factor is not None else self._default_module_cost_factor
        self.module_cost_exponent = module_cost_exponent if module_cost_exponent is not None else self._default_module_cost_exponent
        self.base_CEPCI = base_CEPCI if base_CEPCI is not None else self._default_base_CEPCI
        self.power_utility = bst.PowerUtility()

    def _run(self):
        feed, = self.ins
        retentate, permeate = self.outs

        retentate.T = permeate.T = feed.T
        retentate.P = permeate.P = feed.P

        permeate.empty()
        retentate.empty()

        feed_water_mass = feed.imass[self.water_ID]
        retentate_water = feed_water_mass * (1.0 - self.FeedWater_Recovery_to_Permeate)
        retentate.imass[self.water_ID] = max(0.0, retentate_water)
        permeate.imass[self.water_ID] = max(0.0, feed_water_mass - retentate.imass[self.water_ID])

        import warnings as _warnings
        available_ids = {chem.ID for chem in self.chemicals}

        def _to_id_list(x):
            if x is None:
                return []
            if isinstance(x, (list, tuple, set)):
                return [i for i in x if i is not None]
            return [x]

        retention_map = {}
        attr_map = (
            (_to_id_list(self.TargetProduct_ID), self.TargetProduct_Retention, "TargetProduct"),
            (_to_id_list(self.OtherLargeMolecules_ID), self.OtherLargeMolecules_Retention, "OtherLargeMolecules"),
            (_to_id_list(self.Salt_ID), self.Salt_Retention, "Salt"),
        )
        for ids, retention, label in attr_map:
            missing = []
            for chem_id in ids:
                if chem_id in available_ids:
                    retention_map[chem_id] = retention
                else:
                    missing.append(chem_id)
            if missing:
                _warnings.warn(
                    f"Ultrafiltration: {label} IDs not found in thermo chemicals and will use default retention: {missing}",
                    RuntimeWarning,
                )

        for chem in self.chemicals:
            ID = chem.ID
            if ID == self.water_ID:
                continue
            mass_in = feed.imass[ID]
            if mass_in < 1e-12:
                continue

            current_retention = retention_map.get(ID, self.DefaultSolutes_Retention)
            retentate_mass = mass_in * current_retention
            permeate_mass = mass_in - retentate_mass

            retentate.imass[ID] = max(0.0, retentate_mass)
            permeate.imass[ID] = max(0.0, permeate_mass)

            if permeate.imass[ID] < 0:
                retentate.imass[ID] += permeate.imass[ID]
                permeate.imass[ID] = 0.0
            if retentate.imass[ID] < 0:
                permeate.imass[ID] += retentate.imass[ID]
                retentate.imass[ID] = 0.0

    def _design(self):
        Design = self.design_results
        permeate_stream = self.outs[1]
        if permeate_stream.isempty() or permeate_stream.rho == 0:
            permeate_vol_L_per_hr = 0.0
        else:
            permeate_vol_L_per_hr = permeate_stream.F_vol * 1000.0

        membrane_area_m2 = permeate_vol_L_per_hr / self.membrane_flux_LMH if (self.membrane_flux_LMH > 0 and permeate_vol_L_per_hr > 0) else 0.0
        Design['Membrane Area'] = membrane_area_m2
        Design['membrane_flux_LMH'] = self.membrane_flux_LMH
        Design['TMP_bar'] = self.TMP_bar
        Design['membrane_cost_USD_per_m2'] = self.membrane_cost_USD_per_m2
        Design['membrane_lifetime_years'] = self.membrane_lifetime_years
        Design['equipment_lifetime_years'] = self.equipment_lifetime_years

        self.feed_pump = bst.Pump(None, None, P=self.TMP_bar * 1e5)
        self.feed_pump.ins[0] = self.ins[0].copy()
        self.feed_pump.simulate()
        self.feed_pump._design()
        Design['pump_efficiency'] = 0.85 * 100.0
        self.power_utility.rate = self.feed_pump.power_utility.rate
    
    def _cost(self):
        # --- MODIFIED: Properly calculate total membrane replacement cost over equipment lifetime ---
        area_m2 = self.design_results.get('Membrane Area', 0.0)
        if area_m2 > 0 and self.module_cost_factor > 0 and self.base_CEPCI > 0:
            base_purchase_cost = self.module_cost_factor * (area_m2 ** self.module_cost_exponent)
            current_purchase_cost = base_purchase_cost * (bst.CE / self.base_CEPCI)
            self.baseline_purchase_costs['Membrane System'] = current_purchase_cost
        else:
            self.baseline_purchase_costs['Membrane System'] = 0.0
            
        # Calculate total membrane replacement cost over equipment lifetime
        if (self.membrane_lifetime_years > 0 and
            self.membrane_cost_USD_per_m2 > 0 and
            area_m2 > 0 and
            self.equipment_lifetime_years > 0):
            
            # Calculate number of membrane replacements over equipment lifetime
            num_replacements = self.equipment_lifetime_years / self.membrane_lifetime_years
            
            # Total membrane replacement cost over equipment lifetime
            total_replacement_cost = num_replacements * area_m2 * self.membrane_cost_USD_per_m2
            
            self.baseline_purchase_costs['Membrane replacement'] = total_replacement_cost
        else:
            self.baseline_purchase_costs['Membrane replacement'] = 0.0
            
        self.baseline_purchase_costs['Pump'] = self.feed_pump.purchase_cost
    

import flexsolve as flx
from biosteam import main_flowsheet as F
class IonExchangeCycle(bst.Unit):
    """
    Simulates a complete Ion Exchange (IEX) chromatography cycle as a
    steady-state equivalent unit operation.

    This unit models the loading of a feed stream, binding of target products,
    and subsequent washing, elution, and regeneration steps. It calculates the
    required volumes of all buffers and chemicals based on the column size,
    which is determined by the feed rate and target product concentration.
    The waste streams are separated by cycle phase for downstream processing.

    Parameters
    ----------
    ins :
        [0] Feed: The process stream containing the target product and impurities.
        [1] Equilibration/Wash Buffer (Buffer A): Low-salt buffer.
        [2] Elution Buffer (Buffer B): High-salt buffer to elute the product.
        [3] Regeneration Solution: e.g., NaOH or high molar NaCl.
    outs :
        [0] Product: Concentrated target product in elution buffer.
        [1] FlowthroughWaste: Unbound components from the feed stream.
        [2] WashWaste: Spent equilibration and wash buffer.
        [3] RegenerationWaste: Spent regeneration solution with stripped impurities.

    cycle_time_hr : float
        Total duration of one complete IEX cycle (loading to regeneration), in hours.
    equilibration_CV : float
        Volume of equilibration buffer used, in multiples of Column Volumes (CV).
    wash_CV : float
        Volume of wash buffer used, in multiples of Column Volumes (CV).
    elution_CV : float
        Volume of elution buffer used, in multiples of Column Volumes (CV).
    regeneration_CV : float
        Volume of regeneration solution used, in multiples of Column Volumes (CV).
    resin_DBC_g_L : float
        Dynamic Binding Capacity of the resin in grams of product per liter of resin.
    load_safety_factor : float
        Safety factor for column loading, typically < 1.0 (e.g., 0.8 means column is
        loaded to 80% of its DBC).
    TargetProduct_IDs : tuple[str]
        IDs of the chemical(s) to be captured and eluted as product.
    TargetProduct_Yield : float
        Fraction of the target product in the feed that is recovered in the product stream.
    BoundImpurity_IDs : tuple[str]
        IDs of impurities that also bind to the resin but are mostly removed.
    BoundImpurity_Removal : float
        Fraction of bound impurities in the feed that are sent to the waste stream.
    NonBinding_Carryover : float
        Fraction of non-binding components that ends up in the product stream.

    # ... other costing parameters ...
    """
    _N_ins = 4
    _N_outs = 4 # Changed from 2 to 4

    _F_BM_default = {
        'IEX Column Hardware': 2.5,
        'IEX Resin': 1.5,
        'Pump': 1.89,
    }
    # Auxiliary units for costing
    _auxiliary_unit_names = ('pump',)

    def __init__(self, ID='', ins=None, outs=(), thermo=None, *,
                 # Cycle parameters
                 cycle_time_hr=4.0,
                 equilibration_CV=5.0,
                 wash_CV=5.0,
                 elution_CV=3.0,
                 regeneration_CV=5.0,

                 # Sizing and separation parameters
                 resin_DBC_g_L=50.0,
                 load_safety_factor=0.8,
                 TargetProduct_IDs=('Leghemoglobin',),
                 TargetProduct_Yield=0.95,
                 BoundImpurity_IDs=('Heme_b',),
                 BoundImpurity_Removal=0.93,
                 NonBinding_Carryover=0.04,

                 # Costing parameters
                 resin_cost_USD_per_L=30.0,
                # water treatment
                    # strong acid cation resin: 2~5
                    # weak acid cation resin: 3 ~ 6
                    # strong base anion resin: 7~15
                    # weak base anion resin: 5~10
                # for food tech/beverage/nutrition
                # https://lanxess.com/en/products-and-brands/brands/lewatit/industries/food-and-beverage#:~:text=Ion%20exchange%20resins%20for%20the,and%20food%20and%20drink%20additives.
                # https://www.purolite.com/index/bioprocessing/ion-exchange-chromatography#:~:text=Purolite%20Praesto%20resins%20are%20manufactured,over%20a%20wide%20pH%20range.
                # https://waterfilter.net.au/products/softening-resin-lewatit-s1567#:~:text=Ask%20a%20Question,a%20recurring%20or%20deferred%20purchase.
                    # strong acid cation resin: 10~50
                    # weak acid cation resin: 15 ~ 60
                    # strong base anion resin: 30~100
                    # weak base anion resin: 25~80
                # https://www.cytivalifesciences.com/en/us/shop/chromatography/resins/ion-exchange?sort=NameAsc&chunk=1
                #DuPont (FilmTec™) 
                # Suez Water Technologies & Solutions (formerly GE Water & Process Technologies)
                # Synder Filtration
                # Pall Corporation
                # Sartorius Stedim Biotech
                # Merck Millipore
                # Koch Separation Solutions
                # Toray Industries, Inc.
                # Asahi Kasei
                # Pentair

                 resin_lifetime_years=5.0, # 1~10 years
                 column_hardware_cost_factor=30000.0,
                 column_hardware_cost_exponent=0.6
                ):
        bst.Unit.__init__(self, ID, ins, outs, thermo)

        # Operating parameters
        self.cycle_time_hr = cycle_time_hr
        self.equilibration_CV = equilibration_CV
        self.wash_CV = wash_CV
        self.elution_CV = elution_CV
        self.regeneration_CV = regeneration_CV

        # Separation parameters
        self.resin_DBC_g_L = resin_DBC_g_L
        self.load_safety_factor = load_safety_factor
        if isinstance(TargetProduct_IDs, str): self.TargetProduct_IDs = (TargetProduct_IDs,)
        else: self.TargetProduct_IDs = tuple(TargetProduct_IDs)
        self.TargetProduct_Yield = TargetProduct_Yield
        self.BoundImpurity_IDs = tuple(BoundImpurity_IDs)
        self.BoundImpurity_Removal = BoundImpurity_Removal
        self.NonBinding_Carryover = NonBinding_Carryover

        # Costing
        self.resin_cost_USD_per_L = resin_cost_USD_per_L
        self.resin_lifetime_years = resin_lifetime_years
        self.column_hardware_cost_factor = column_hardware_cost_factor
        self.column_hardware_cost_exponent = column_hardware_cost_exponent

        # Initialize internal pump for power calculation
        self.pump = bst.Pump(None, P=4 * 1e5) # Assume 4 bar pressure drop

    def _run(self):
        # Unpack streams
        feed, buffer_A, buffer_B, regen_sol = self.ins
        product, ft_waste, wash_waste, regen_waste = self.outs

        # --- Initialize Output Streams ---
        # The product stream is primarily elution buffer
        product.copy_like(buffer_B)
        # The flowthrough waste initially contains everything from the feed
        ft_waste.copy_like(feed)
        # The wash waste is simply the spent wash buffer
        wash_waste.copy_like(buffer_A)
        # The regeneration waste is primarily the regeneration solution
        regen_waste.copy_like(regen_sol)

        # Create sets for faster checking
        target_ids = set(self.TargetProduct_IDs)
        bound_impurity_ids = set(self.BoundImpurity_IDs)

        # --- Distribute Solutes from the Feed Stream ---
        # Iterate over all components in the feed and assign them to the correct output
        for chem in self.chemicals:
            solute_in_feed = feed.imass[chem.ID]
            if solute_in_feed < 1e-12:
                continue

            if chem.ID in target_ids:
                # Target product binds, then elutes or is stripped in regeneration
                to_product = solute_in_feed * self.TargetProduct_Yield
                to_regen = solute_in_feed - to_product

                product.imass[chem.ID] += to_product
                regen_waste.imass[chem.ID] += to_regen
                # Remove the entire component from flowthrough, as it binds
                ft_waste.imass[chem.ID] = 0

            elif chem.ID in bound_impurity_ids:
                # Bound impurities bind, then are mostly stripped in regeneration
                to_regen = solute_in_feed * self.BoundImpurity_Removal
                to_product = solute_in_feed - to_regen

                product.imass[chem.ID] += to_product
                regen_waste.imass[chem.ID] += to_regen
                # Remove the entire component from flowthrough, as it binds
                ft_waste.imass[chem.ID] = 0

            else:
                # Non-binding components mostly go to flowthrough, with some carryover
                # This applies to water, salts in the feed, and other impurities
                carryover_to_product = solute_in_feed * self.NonBinding_Carryover
                
                product.imass[chem.ID] += carryover_to_product
                # The rest remains in the flowthrough, so we subtract the carryover part
                ft_waste.imass[chem.ID] -= carryover_to_product

        # --- Set Final Stream Temperatures ---
    
        product.T = buffer_B.T
        ft_waste.T = feed.T
        wash_waste.T = buffer_A.T
        regen_waste.T = regen_sol.T

    def _design(self):
        # This method remains unchanged, as it is based on inputs.
        D = self.design_results

        # Calculate resin volume based on target product loading
        target_mass_per_cycle_kg = sum(self.ins[0].imass[ID] for ID in self.TargetProduct_IDs) * self.cycle_time_hr
        effective_DBC = self.resin_DBC_g_L * self.load_safety_factor
        if effective_DBC > 0 and target_mass_per_cycle_kg > 0:
            resin_volume_L = (target_mass_per_cycle_kg * 1000) / effective_DBC
        else:
            resin_volume_L = 1.0  # Minimum volume for costing

        D['Resin Volume (CV)'] = resin_volume_L
        D['Cycle time (hr)'] = self.cycle_time_hr
        D['Target Product Yield'] = self.TargetProduct_Yield * 100
        D['Bound Impurity Removal'] = self.BoundImpurity_Removal * 100

        # Store CV values in design results
        D['Equilibration CV'] = self.equilibration_CV
        D['Wash CV'] = self.wash_CV
        D['Elution CV'] = self.elution_CV
        D['Regeneration CV'] = self.regeneration_CV

        # Cost the pump based on total liquid processed
        total_flow_stream = self.ins[0].copy()
        for s in self.ins[1:]:
            total_flow_stream.mass += s.mass

        if total_flow_stream.F_mass > 0:
            self.pump.ins[0] = total_flow_stream
            self.pump.simulate()
            self.pump._design()
            self.power_utility.rate = self.pump.power_utility.rate

    def _cost(self):
        # This method remains unchanged.
        C = self.baseline_purchase_costs
        D = self.design_results

        resin_volume_L = D.get('Resin Volume (CV)', 0.0)

        # Cost of the column hardware
        if resin_volume_L > 0:
            hw_cost = self.column_hardware_cost_factor * (resin_volume_L ** self.column_hardware_cost_exponent)
            C['IEX Column Hardware'] = bst.CE / 500 * hw_cost
        else:
            C['IEX Column Hardware'] = 0.0

        # Cost of the resin (initial fill + replacements)
        if self.resin_lifetime_years > 0 and resin_volume_L > 0:
            plant_lifetime = getattr(F.stream, 'plant_life', 20)
            replacements = plant_lifetime / self.resin_lifetime_years
            resin_cost = self.resin_cost_USD_per_L * resin_volume_L * replacements
            C['IEX Resin'] = resin_cost
        else:
            C['IEX Resin'] = 0.0

        # Cost of the pump
        self.pump._cost()
        C['Pump'] = self.pump.purchase_cost


class ResinAdsorption(IonExchangeCycle): pass

class SprayDryer(bst.SprayDryer):pass

@cost('Flow rate', 'Tank', S=1171, units='kg/hr',
        CE=522, cost=196000, n=0.7, BM=2)
class AmmoniaStorageTank(bst.StorageTank): pass


@cost('Flow rate', 'Tank', S=1981, units='kg/hr',
        CE=522, cost=96000, n=0.7, BM=1.5)
@cost('Flow rate', 'Pump', S=1981, units='kg/hr',
        CE=522, cost=7493, n=0.8, BM=2.3, kW=0.5)
class SulfuricAcidStorageTank(bst.StorageTank): pass


@cost('Flow rate', 'Pump', S=43149, units='kg/hr',
        CE=522, cost=8200, n=0.8, BM=2.3, kW=7.457)
@cost('Flow rate', 'Tank', S=40414, units='kg/hr',
        CE=522, cost=439000, n=0.7, BM=1.8)
@cost('Flow rate', 'Agitator', S=40414, units='kg/hr',
        CE=522, cost=31800, n=0.5, BM=1.5, kW=11.3205)
class SeedHoldTank(bst.Mixer): pass



class NeutralizationTank1(bst.Unit):
    _N_ins = 2
    _N_outs = 1
    
    _F_BM_default = {
        'Tank': 2.0,
        'Agitator': 1.5,
        'Cooler': 2.3,
    }
    
    _units = {
        'Flow rate': 'kg/hr',
        'Tank volume': 'm3',
        'Agitator power': 'kW',
        'Cooling duty': 'kJ/hr',
    }
    
    def __init__(self, ID='', ins=None, outs=(), thermo=None, T=None, reactions=None, 
                 residence_time=2.0, agitator_kW_per_m3=0.5):
        super().__init__(ID, ins, outs, thermo)
        self.T = T or 298.15  # Default temperature if not specified
        self.residence_time = residence_time  # hours
        self.agitator_kW_per_m3 = agitator_kW_per_m3  # kW per m3 of tank volume
        
        # Initialize reactions after thermo is available
        if reactions is None:
            chemicals = self.chemicals
            self.reaction1 = bst.Rxn(
                'H2SO4 + 2 NaOH -> Na2SO4 + 2 H2O', reactant='NaOH', X=1, chemicals=chemicals
            )
            self.reaction2 = bst.Rxn(
                'H2SO4 + Na2SO4 -> 2 NaHSO4', reactant='H2SO4', X=1, chemicals=chemicals
            )
            self.reactions = bst.SRxn([self.reaction1, self.reaction2])
        else:
            self.reactions = reactions
        
        # Initialize auxiliary units
        self.cooler = bst.HXutility(None, None, T=self.T)

    def _run(self):
        feed1, feed2 = self.ins
        out, = self.outs
        
        # Mix the two inlet streams
        out.mix_from(self.ins)
        
        # Store initial enthalpy before reaction
        H_before = out.H
        
        # Run reactions if specified
        if self.reactions:
            if hasattr(self.reactions, '__iter__'):
                # Multiple reactions
                for reaction in self.reactions:
                    reaction(out)
            else:
                # Single reaction
                self.reactions(out)
        
        # Calculate heat of reaction
        H_after_reaction = out.H
        heat_of_reaction = H_after_reaction - H_before
        
        # Cool to target temperature using auxiliary cooler
        self.cooler.ins[0] = out.copy()
        self.cooler.T = self.T
        self.cooler.simulate()
        
        # Update outlet stream
        out.copy_like(self.cooler.outs[0])
        out.T = self.T

    def _design(self):
        Design = self.design_results
        out = self.outs[0]
        
        # Calculate tank volume based on residence time and water flow rate only
        # to avoid molar volume calculation issues with salts
        water_mass_flow = out.imass['H2O']  # kg/hr
        if water_mass_flow > 0:
            water_density = 1000  # kg/m3 approximate density of water
            water_vol_flow = water_mass_flow / water_density  # m3/hr
            tank_volume_m3 = water_vol_flow * self.residence_time
        else:
            tank_volume_m3 = 1.0  # Minimum volume
            
        # Calculate agitator power based on tank volume
        agitator_power_kW = tank_volume_m3 * self.agitator_kW_per_m3
        
        # Get cooling duty from auxiliary cooler
        cooling_duty_kJ_hr = abs(self.cooler.Hnet) if hasattr(self.cooler, 'Hnet') else 0
        
        # Store design results
        Design['Flow rate'] = sum(s.F_mass for s in self.ins)
        Design['Tank volume'] = tank_volume_m3
        Design['Agitator power'] = agitator_power_kW
        Design['Cooling duty'] = cooling_duty_kJ_hr
        
        # Set power utility for agitator
        self.power_utility.rate = agitator_power_kW
        
        # Set heat utility for cooling (cooling water)
        if cooling_duty_kJ_hr > 0:
            self.add_heat_utility(-cooling_duty_kJ_hr, self.T)

    def _cost(self):
        C = self.baseline_purchase_costs
        D = self.design_results
        
        tank_volume = D['Tank volume']
        flow_rate = D['Flow rate']
        agitator_power = D['Agitator power']
        cooling_duty = D['Cooling duty']
        
        # Cost tank based on volume
        if tank_volume > 0:
            C['Tank'] = bst.CE / 522 * 96000 * (tank_volume / 10) ** 0.7
        
        # Cost agitator based on power
        if agitator_power > 0:
            C['Agitator'] = bst.CE / 522 * 31800 * (agitator_power / 11.3) ** 0.5
        
        # Cost cooler based on cooling duty
        if cooling_duty > 0:
            # Estimate cooler cost based on heat duty (simplified approach)
            C['Cooler'] = bst.CE / 522 * 50000 * (cooling_duty / 1e6) ** 0.6
        else:
            C['Cooler'] = 0




